<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode 基础题目</title>
    <url>/2019/08/14/OJ-LeetCode%E5%9F%BA%E7%A1%80%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>分享一些基础题目题解和标答。</p>
<a id="more"></a>
<h3 id="206-Easy-反转链表-Reverse-Linked-List"><a href="#206-Easy-反转链表-Reverse-Linked-List" class="headerlink" title="#206 [Easy] 反转链表 Reverse Linked List"></a>#206 [Easy] 反转链表 <a href="https://leetcode-cn.com/problems/reverse-linked-list/">Reverse Linked List</a></h3><blockquote>
<p>反转一个单链表。</p>
</blockquote>
<p>经典题目，有迭代和递归解法：</p>
<p>迭代解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre, *now, *next, *new_head;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        now = head-&gt;next;</span><br><span class="line">        pre = head;</span><br><span class="line">        pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            next = now-&gt;next;</span><br><span class="line">            now-&gt;next = pre;</span><br><span class="line">            <span class="keyword">if</span>(next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                pre = now;</span><br><span class="line">                now = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>迭代解即是用新指针来保存前后元素，遍历一遍链表即可反转。</p>
<blockquote>
<p> 执行用时 :16 ms, 在所有 C++ 提交中击败了52.36%的用户</p>
<p>内存消耗 :9.1 MB, 在所有 C++ 提交中击败了67.37%的用户</p>
</blockquote>
<p>递归解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *newHead = recur(head, head-&gt;next);</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">recur</span><span class="params">(ListNode* node, ListNode* next)</span></span>&#123;</span><br><span class="line">        ListNode *nnext = next-&gt;next;</span><br><span class="line">        next-&gt;next = node;</span><br><span class="line">        <span class="keyword">if</span>(nnext == <span class="literal">NULL</span>) <span class="keyword">return</span> next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> recur(next, nnext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个更标准的递归做法基于反向处理链表，可以不需要新的函数。(Java)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :28 ms, 在所有 C++ 提交中击败了5.93%的用户</p>
<p>内存消耗 :9.3 MB, 在所有 C++ 提交中击败了11.86%的用户</p>
</blockquote>
<hr>
<h3 id="21-Easy-合并两个有序链表-Merge-Two-Sorted-Lists"><a href="#21-Easy-合并两个有序链表-Merge-Two-Sorted-Lists" class="headerlink" title="#21 [Easy] 合并两个有序链表 Merge Two Sorted Lists"></a>#21 [Easy] 合并两个有序链表 <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">Merge Two Sorted Lists</a></h3><blockquote>
<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
</blockquote>
<p>标准迭代，递归也可以但是感觉会慢。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *root = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *iter = root;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> || l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="literal">NULL</span> &amp;&amp; (l2 == <span class="literal">NULL</span> || l1-&gt;val &lt;= l2-&gt;val))&#123;</span><br><span class="line">                iter-&gt;next = l1;</span><br><span class="line">                iter = iter-&gt;next;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(l2 != <span class="literal">NULL</span> &amp;&amp; (l1 == <span class="literal">NULL</span> || l2-&gt;val &lt;= l1-&gt;val))&#123;</span><br><span class="line">                iter-&gt;next = l2;</span><br><span class="line">                iter = iter-&gt;next;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :12 ms, 在所有 C++ 提交中击败了83.66%的用户</p>
<p>内存消耗 :8.9 MB, 在所有 C++ 提交中击败了82.84%的用户</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>习题</category>
        <category>OJ</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>LeetCode</tag>
        <tag>习题</tag>
      </tags>
  </entry>
  <entry>
    <title>凸问题习题</title>
    <url>/2019/06/18/%E5%87%B8%E9%97%AE%E9%A2%98%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<p>《凸优化》第四章部分习题。</p>
<a id="more"></a>
<h3 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h3><p>(a) </p>
<p>先证充分性： $Av\preceq 0$ ，则对于任意一点$x_0\in \textbf{dom}f$， 有 </p>
<script type="math/tex; mode=display">
\forall k\in R^+, A(x_0+kv)=Ax_0+k\cdot Av\preceq Ax_0 \prec b</script><p>即 $x_0+kv$ 也在定义域中。所以 $\textbf{dom} f$ 无界。</p>
<p>再证必要性：若 $\textbf{dom} f$ 无界，则存在序列 $x^k\in\textbf{dom} f$ 在 $k\rightarrow \infty$ 时 $|x^k|_2\rightarrow \infty$ 。若不存在 $v\neq 0$ 满足 $Av\preceq 0$ ，则对于 $v\neq 0$ ，$Av$ 必定存在某一分量大于0。 令 $A(kv)=k\cdot Av$  为对 $Ax^k$ 的一个逼近，即可使 $v=x^k/|x^k|_2$ ，那么 $k\rightarrow \infty$ 时， $kv$ 逼近 $x^k$ ，应有 $A(kv)\prec b$ ，但由于 $Av$ 必定存在某一分量大于0，所以 $k\cdot Av\prec b$ 不成立，此处 $b$ 亦可为任意实数。 结论自相矛盾，假设不成立。所以存在 $v\neq 0$ 满足 $Av\preceq 0$ 。</p>
<p>(b) </p>
<p>由择一定理可以得到，存在 $v$ 满足 $Av\preceq 0, Av\neq 0$ 的充要条件是，不存在 $z\succ 0$ 使得 $A^Tz=0$ 。</p>
<p>对于原命题，先证充分性：存在 $Av\preceq 0$ ， $Av\neq 0$ ，即对 $Av$ 的每个分量都有 $a^T_iv_i\leq 0$ ，且 $Av\neq 0$ 。由于(1)可知此时定义域无界，对于 $x_0\in \textbf{dom} f$ ，有 $\forall k\in R^+, x_0+kv\in\textbf{dom} f$ :</p>
<script type="math/tex; mode=display">
f_0(x_0+kv)=-\sum^m_{i=1}\log(b_i-a^T_ix_0-k\cdot a^T_iv)</script><p>因为对每个分量都有 $a^T_iv\leq 0$ 且 $Av\neq 0$ ，在 $k\rightarrow \infty$ 时很容易看出 $f_0(x_0+kv)\rightarrow -\infty$ ，即 $f_0$ 无下界。</p>
<p>再证必要性：若 $f_0$ 无下界，设序列 $x_1,x_2,\cdots,x_k$ 为无界序列，即 $k\rightarrow \infty\Rightarrow b-Ax\rightarrow -\infty\Rightarrow f_0(x_k)\rightarrow -\infty$ 。且存在 $z\succ 0$ ，使得 $A^Tz=0$ ，展开 $f_0(x_k)$ 在 $x_0$ 处的一阶条件：</p>
<script type="math/tex; mode=display">
f_0(x_k)\geq f_0(x_0)+\sum^m_{i=1}\frac{1}{b_i-a^T_ix}a_i^T(x_k-x_0)</script><p>(c)</p>
<p>设其定义域 $\textbf{dom} f_0$ 有界，则 $f_0$ 下水平集为闭，极小值可达。<br>若其定义域无界，则由 (a) 有其等同于存在 $v\neq 0, Av\preceq 0$ ； $f_0$ 有下界，则不存在  $v$ 使 $Av\preceq 0, Av\neq 0$ 。因为 $v\neq 0$ ，所以只有 $A=0$才能满足条件，此时函数值恒为定值，极小值可达。</p>
<p>(d)</p>
<p>由最优性条件：</p>
<script type="math/tex; mode=display">
\triangledown f_0(x)=\sum^m_{i=1}\frac{1}{b_i-a^T_ix}a_i=0</script><p>若 $Av=0$ ，则有 $a^T_iv=0$ ，即 $b_i-a^T_ix^\star=b_i-a^T_ix^\star+a^T_iv=b_i-a^T_i(x^\star+v)$ ，即对于任意最优解 $x^\star$ ，$x^\star+v$ 也是最优解( $Av=0$ ) 。</p>
<blockquote>
<p>总结：</p>
<p>这题我认为主要的点是在：</p>
<ul>
<li>怎么判断无界(用序列 $x+kv$ 逼近无穷)</li>
<li>怎么表达可达($X_{opt}$非空，大部分情况下问题应有界)</li>
<li>拆矩阵分析</li>
</ul>
</blockquote>
<h3 id="4-8"><a href="#4-8" class="headerlink" title="4.8"></a>4.8</h3><p>(a)</p>
<p>若问题不可行，则 $p^\star=+\infty$ 。</p>
<p>若问题可行，将 $c$ 分解为 $c=A^T\lambda+\hat{c}$ ，$A\hat{c}=0$ ：<br>若 $c$ 与 $A$ 的零空间正交，因为正交性，有 $\hat{c}=0$， $c^Tx=\lambda^TAx=\lambda b$ 即最优值为 $\lambda b$ ；<br>若 $c$ 与 $A$ 的零空间不正交，则问题无下界，因为 $c^Tx=\lambda b+\hat{c}^Tx$ ，$x$ 在可行集内可以无限小，只需要无限减小 $\hat{c}$ 分量的值。</p>
<p>所以此问题的最优值为</p>
<script type="math/tex; mode=display">
p^\star=\begin{cases}
 & +\infty, \text{ if } \forall x, Ax\neq b\\
 & \lambda b,\text{ if for some } \lambda<0, c=A^T\lambda=0 \\ 
 & -\infty, \text{ if } otherwise
\end{cases}</script><p>(b)</p>
<p>问题可行集为半空间，此问题一定可行。</p>
<p>将 $c$ 分解为 $c=\lambda a +\hat{a}$ ，$a^T\hat{a}=0$ ，即分解成与 $a$ 平行和正交的两个分量。目标函数可以表示为： $c^Tx=\hat{a}^Tx+\lambda a^Tx$ ，可以容易知道 $c$ 与 $a$ 平行时，问题才有界。否则解可以无限在 $\hat{a}$ 的方向上滑动。且 $c,a$ 必须反向，即 $\lambda &lt;0$ ，此时最优解为 $\lambda a^Tx=\lambda b$ 。</p>
<p>所以此问题的最优值为</p>
<script type="math/tex; mode=display">
p^\star=\begin{cases}
 & \lambda b,\text{ if for some } \lambda<0, \hat{a}=0 \\ 
 & -\infty, \text{ if } \lambda\geq0 
\end{cases}</script><p>(c)</p>
<p>问题可行集为矩形，问题一定可行。由于  $l\preceq x\preceq u$ ，容易知道最优值为</p>
<script type="math/tex; mode=display">
p^\star=\begin{cases}
 & c^Tl,\text{ if } c<0,  \\ 
 & c^Tu, \text{ if } c>0, \\
 & \forall x \text{ in rectangle, if } c=0 
\end{cases}</script><p>(d)</p>
<p>将 $c$ 中元素排序，设最小元素为 $c_1$ ，显然最优值为 $p^\star=c_1$ ，即投资组合优化问题中全部投资收益率最高的项目。</p>
<p>等式约束被替换为不等式约束时，由于 $1^Tx$ 可以为0，则在 $c_1&gt;0$ 时，最优值为 $p^\star=0$ (即投资组合优化问题中，收益率为负时，可以选择不投资)。总最优值为 $p^\star=\min{0,c_1}$ 。</p>
<p>(e)</p>
<p>仍然将 $c$ 中元素排序，设为 $c_1\leq c_2\leq \cdots \leq c_n$ ，显然最优值为</p>
<script type="math/tex; mode=display">
p^\star=\sum_{i=1}^\alpha c_i</script><p>即全预算投资收益率前 $\alpha$ 的项目。</p>
<p>若 $\alpha$ 不为整数，最优值仍然可以按照原思想得出:</p>
<script type="math/tex; mode=display">
p^\star=\sum_{i=1}^{\lfloor\alpha\rfloor}c_i+(\alpha-\lfloor\alpha\rfloor)c_{\lfloor\alpha\rfloor}</script><p>若等式变为 $1^Tx\leq\alpha$ ，则对于收益率为负的部分，可以选择不投资。令 $c_m$ 为其中最大的负值，则最优值为：</p>
<script type="math/tex; mode=display">
p^\star=\sum_{i=m}^{\min\{\alpha+m,n\}}c_i</script><p>(f)</p>
<p>可以定义收益性价比为 $v<em>i=c_i/d_i$ ，容易知道到全资投资收益性价比高的总会拥有比别的方案更高的收益。按性价比对 $c$ 中元素排序，设为 $v_1\leq v_2\leq \cdots\leq v_n$，且 $\sum</em>{i=1}^m d<em>ix_i\leq \alpha\leq \sum</em>{i=1}^{m+1}d_ix_i$ 显然最优值为</p>
<script type="math/tex; mode=display">
p^\star=\sum_{i=1}^{m}c_i+c_{m+1}\frac{\alpha-\sum_{i=1}^md_ix_i}{d_i}</script><blockquote>
<p>总结:</p>
<p>如何显示求LP的解？一个比较常用的方法是把系数 $c$ 拆成两个互相正交方向，通常一个是下降方向，即另一个和约束平面平行。这种方法在其他题目上也有体现，比如将矩阵拆成正定矩阵和非正定矩阵的和。 </p>
</blockquote>
<h3 id="4-24"><a href="#4-24" class="headerlink" title="4.24"></a>4.24</h3><p>(a)</p>
<p>L1范数:</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } &\sum_{i=1}^m|a_i^Tx-b|\\
\end{align}</script><p>直接引入新优化实变量 $t_i=|a^T_ix-b|$ ，则引入了新约束 $|a^T_ix-b|\leq t_i$ ， 可以将约束用范数展开：</p>
<script type="math/tex; mode=display">
\begin{align}
&\sum|a^T_ix-b|\\
&=\sum\sqrt{[Re(a^T_ix-b)]^2+[Im(a^T_ix-b)]^2}\\
&=\sum\sqrt{[Re(a^T_i)Re(x)-Im(a^T_i)Im(x)-Re(b)]^2}\\
&\overline{+[Re(a^T_i)Im(x)+Im(a^T_i)Re(x)-Im(b)]^2}\\
&=\|\begin{bmatrix}
 Re(a_i^T)&-Im(a^T_i) \\ 
 Im(a^T_i)&Re(a_I^T) 
\end{bmatrix}\begin{bmatrix}
 Re(x)\\ Im(x)
\end{bmatrix}-\begin{bmatrix}
 Re(b)\\ Im(b)
\end{bmatrix}\|_2
\end{align}</script><p>SOCP形式：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } &\sum_{i=1}^m t_i\\
\text{subject to } &
 \|\begin{bmatrix}
 Re(a_i^T)&-Im(a^T_i) \\ 
 Im(a^T_i)&Re(a_I^T) 
\end{bmatrix}\begin{bmatrix}
 Re(x)\\ Im(x)
\end{bmatrix}-\begin{bmatrix}
 Re(b)\\ Im(b)
\end{bmatrix}\|_2\leq t_i
\end{align}</script><p>(b)</p>
<p>L2范数：</p>
<p>同L1范数，可以容易写出</p>
<script type="math/tex; mode=display">
\begin{align}
\|Ax-b\|_2&={\|Re(Ax-b)\|_2+\|Im(Ax-b)\|_2}^{1/2}\\
&=\|\begin{bmatrix}
 Re(A)&-Im(A) \\ 
 Im(A)&Re(A) 
\end{bmatrix}\begin{bmatrix}
 Re(x)\\ Im(x)
\end{bmatrix}-\begin{bmatrix}
 Re(b)\\ Im(b)
\end{bmatrix}\|_2^{1/2}
\end{align}</script><p>SOCP形式:</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } &\sum_{i=1}^m t_i\\
\text{subject to } &
 \|\begin{bmatrix}
 Re(A)&-Im(A) \\ 
 Im(A)&Re(A) 
\end{bmatrix}\begin{bmatrix}
 Re(x)\\ Im(x)
\end{bmatrix}-\begin{bmatrix}
 Re(b)\\ Im(b)
\end{bmatrix}\|_2^{1/2}\leq t_i
\end{align}</script><p>(c)</p>
<p>L∞范数：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } \max_{i=1,\cdots,m} |a_i^Tx-b|
\end{align}</script><p>同样引入新约束变量：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } &t\\
\text{subject to } &|a^T_ix-b|\leq t
\end{align}</script><p>SOCP形式:</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } &t\\
\text{subject to } &
 \|\begin{bmatrix}
 Re(a_i^T)&-Im(a^T_i) \\ 
 Im(a^T_i)&Re(a_I^T) 
\end{bmatrix}\begin{bmatrix}
 Re(x)\\ Im(x)
\end{bmatrix}-\begin{bmatrix}
 Re(b)\\ Im(b)
\end{bmatrix}\|_2\leq t
\end{align}</script><blockquote>
<p>总结：凑SOCP形式，经常会凑出来目标函数为单一个 $t$ (正常情况是 $c^Tx$ 或 $f^Tx$)。将其他条件凑成二范数的约束(二次锥约束)。</p>
</blockquote>
<h3 id="4-40"><a href="#4-40" class="headerlink" title="4.40"></a>4.40</h3><p>(a) LP：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } &c^Tx+d\\
\text{subject to } &Gx\preceq h\\
&Ax=b
\end{align}</script><p>直接把不等式约束写成对应矩阵形式即可，对应SDP：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } &c^Tx+d\\
\text{subject to } &\textbf{diag}(Gx-h)\preceq 0\\
&Ax=b
\end{align}</script><p>(b) QP:</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } &(1/2)x^TPx+q^Tx+r,\ P\in S^n_+\\
\text{subject to } &Gx\preceq h\\
&Ax=b
\end{align}</script><p>设 $A\in S^r_{++}, C\in S^s, B\in R^{r\times s}$ ，有</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
 A&B \\ 
 B^T&C 
\end{bmatrix}\succeq 0\Leftrightarrow C-B^TA^{-1}B\succeq 0</script><p>令 $P=QQ^T, Q\in R^{n\times r}$ ，则目标函数变为 $(1/2)(Q^Tx)^T(Q^Tx)+q^Tx+r$ ，引入新优化变量 $t\geq x^TPx=(Q^Tx)^T(Q^Tx)$  ，目标函数变为 $(1/2)t+q^Tx+r$ ，且有新的约束 $t\geq (Q^Tx)^T(Q^Tx),\ i.e.\ tI-(Q^Tx)^TI^{-1}(Q^Tx)\succeq 0$ 。按照上式变换新约束，则原问题对应SDP为：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } &(1/2)t+q^Tx+r\\
\text{subject to } &\textbf{diag}(Gx-h)\preceq 0\\
&\begin{bmatrix}
I& Q^Tx\\ 
x^TQ &tI 
\end{bmatrix}\succeq0\\
&Ax=b
\end{align}</script><p>优化变量为 $x,t$ 。</p>
<p>QCOP:</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } &(1/2)x^TP_0x+q_0^Tx+r_0)\\
\text{subject to } &(1/2)x^TP_ix+q_i^Tx+r_i\leq 0,\ i=1,\cdots,i\\
&Ax=b
\end{align}</script><p>仿照上述过程，处理约束 $(1/2)x^TP_ix+q_i^Tx+r_i =(1/2)(Q_i^Tx)^T(Q_i^Tx)+q^T_ix+r_i\leq 0$ ，引入新的优化变量 $t_i$ ，则约束变为 $(1/2)t_i+q_i^Tx+r_i\leq 0$ ，同时引入新约束 $t_iI-(Q_i^Tx)^TI^{-1}(Q_i^Tx)\succeq 0$ 。原问题对应SDP为：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } &(1/2)t_0+q_0^Tx+r_0\\
\text{subject to } &(1/2)t_i+q^T_ix+r_i\leq 0\\
&\begin{bmatrix} 
I& Q_i^Tx\\ 
x^TQ &t_iI 
\end{bmatrix}\succeq0,\ i=0,1,\cdots,m\\
&Ax=b
\end{align}</script><p>SOCP:</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } &c^Tx\\
\text{subject to } &\|A_ix+b_i\|_2\leq c^T_ix+d_i,i=1,\cdots,m\\
&Fx=g
\end{align}</script><p>仿照上述过程，约束可以化为</p>
<script type="math/tex; mode=display">
\begin{align}
(A_ix+b_i)^T(A_ix+b_i)&\leq (c_i^Tx+d_i)^2\\
(c^T_ix+d_i)(c_i^Tx+d_i)-(A_ix+b_i)^T(A_ix+b_i)&\geq0\\
(c^T_ix+d_i)-(c^T_ix+d_i)^{-1}(A_ix+b_i)^T(A_ix+b_i)&\geq0\\
(c^T_ix+d_i)I-(A_ix+b_i)^T(c^T_ix+d_i)^{-1}I^{-1}(A_ix+b_i)&\succeq 0\\
\begin{bmatrix} 
(c^T_ix+d_i)I& A_ix+b_i\\ 
(A_ix+b_i)^T & (c^T_ix+d_i)I
\end{bmatrix}&\succeq 0
\end{align}</script><p> 原问题SDP为：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } &c^Tx\\
\text{subject to } &\begin{bmatrix} 
(c^T_ix+d_i)I& A_ix+b_i\\ 
(A_ix+b_i)^T & (c^T_ix+d_i)I
\end{bmatrix}\succeq 0\\
&Fx=g
\end{align}</script><p>(c) </p>
<p>引入新优化变量 $t=(Ax+b)^TF(x)^{-1}(Ax+b)$ ，则引入了新约束 $(Ax+b)^TF(x)^{-1}(Ax+b)-t\leq 0$ ，仿照上述形式，约束变为：</p>
<script type="math/tex; mode=display">
\begin{align}
\begin{bmatrix} 
F(x)& Ax+b\\ 
(Ax+b)^T & tI
\end{bmatrix}&\succeq 0
\end{align}</script><p>问题可以化成等价的上境图形式，同时也是SDP形式：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } &t\\
\text{subject to } &\begin{bmatrix} 
F(x)& Ax+b\\ 
(Ax+b)^T & tI
\end{bmatrix}\succeq 0\\
\end{align}</script><blockquote>
<p>总结：</p>
<p>SDP更广所以LP、QP、QCQP、SOCP都可以转换成SDP形式。这里的Hint非常有用，提供了通过变量代换将约束/目标函数转换成对角阵形式约束的方法。</p>
</blockquote>
<h3 id="4-43"><a href="#4-43" class="headerlink" title="4.43"></a>4.43</h3><p>(a)</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } &\lambda_1(x)\\
\end{align}</script><p>引入新优化变量 $t=\lambda_1(x)$ ，则容易知道引入了新约束 $A(x)\preceq tI$ 即 $A(x)-tI$ 负定。SDP形式为:</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } &t\\
\text{subject to } &A(x)\preceq tI
\end{align}</script><p>(b)</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } \lambda_1(x)-\lambda_m(x)
\end{align}</script><p>引入新优化变量 $t_1=\lambda_1(x), t_2=\lambda_m(x)$ ，仿照上题可直接写出SDP形式</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } &t_1-t_2\\
\text{subject to } &t_2I\preceq A(x)\preceq t_1I
\end{align}</script><p>(c)</p>
<script type="math/tex; mode=display">
\begin{align}
&\text{minimize } \lambda_1(x)/\lambda_m(x)\\
&\text{subject to } A(x)\succ 0
\end{align}</script><p>引入新变量 $\lambda=\lambda_1(x), \gamma=\lambda_m(x)$ ，同时引入了新约束 $\gamma I\preceq A(x)\preceq \lambda I$ 。作变量替换 $y=x/\gamma, t=\lambda/\gamma, s=1/\gamma$ ，则目标函数就变成了 $t$ ，约束可以两边同除 $\gamma$ 消元：$I\preceq A(x)/\gamma \preceq tI$ ，将 $A(x)$ 展开可以得到更清晰的形式：$I\preceq 1/\gamma A_0+y_1A_1+\cdots+y_nA_n\preceq tI$ 。因为至少有一个 $x$ 满足 $A(x)\succ 0$ ，所以需要 $\gamma &gt; 0$ ，即 $1/\gamma &gt;0$ 。</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } &t\\
\text{subject to } &s> 0\\
&I\preceq sA_0+y_1A_1+\cdots+y_nA_n\preceq tI
\end{align}</script><p>(d)</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } |\lambda_1(x)|+\cdots+|\lambda_m(x)|
\end{align}</script><p> $A(x)$ 变形为正负部 $A(x)=A<em>+-A</em>-$，这样 $A<em>+,A</em>-$ 都绝对半正定。设 $t<em>+=\textbf{tr}A</em>+, t<em>-=\textbf{tr}A</em>-$ ，可以看出正负部各自拥有原矩阵的正特征值和负特征值，即两者和即为目标函数。原问题SDP：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{minimize } &\textbf{tr}A_++\textbf{tr}A_-\\
\text{subject to } &A(x)=A_+-A_-\\
&A_+\succeq 0， A_-\succeq 0
\end{align}</script><blockquote>
<p>总结:</p>
<p>优化特征值的等价问题。常用的等价问题代换除了特征值&lt;=&gt;单位阵，还有小于&lt;=&gt;极大值小于；。。</p>
</blockquote>
<h3 id="4-53"><a href="#4-53" class="headerlink" title="4.53"></a>4.53</h3><p>设两个点 $t_1, t_2\in \textbf{R}^q$ 在集合里，即满足 $f_0(x_1)\preceq_K t_1, f_0(x_2)\preceq_K t_2$ ，有原向量优化为凸问题，即 $f_0$ 是 K-凸的，即 </p>
<script type="math/tex; mode=display">
f_0[\theta x_1+(1-\theta)x_2]\preceq_K \theta f_0(x_1)+(1-\theta)f_0(x_2)</script><p>所以对 $0\leq\theta\leq1$ ，有：</p>
<script type="math/tex; mode=display">
\begin{align}
&\theta t_1+(1-\theta)t_2-\theta f_0(x_1)-(1-\theta)f_0(x_2)\\
=&\theta (t_1-f_0(x_1))+(1-\theta)(t_2-f_0(x_2))\in K\\
i.e.\ &f_0[\theta x_1+(1-\theta)x_2]\preceq_K\theta f_0(x_1)+(1-\theta)f_0(x_2)\preceq_K t_1+(1-\theta)t_2
\end{align}</script><p>因为原向量优化为凸问题， $\theta x_1+(1-\theta)x_2$ 在可行集中，即 $\theta t_1+(1-\theta)t_2\in A$ ，$A$ 为凸集。</p>
<p>若 $a$ 为 $A$ 的极小元，$o$ 为 $O$ 的极小元，将 $a$ 分解成 $O$ 上的元素的形式，即  $a=a’+b, a’\in O, b\succeq_K 0$ 。由于 $A$ 是凸集，则 $a=a’+kb$ 也属于 $A$ ，可以得到 $b=0$ 否则 $k&lt;1$ 时 $a$ 将不是极小元。此时由于 $a$ 的极小元性质，对于任意 $v\in A, v\preceq_K a \Rightarrow v=a$ 。那么对于任意 $v’\in O, v\preceq_K a’ \Rightarrow v’\in A, v\preceq_K a’=a \Rightarrow v=a=a’$  ，即 $v’$ 满足 $O$ 中的极小元性质，且 $v=a$ ，即两者极小元相同。</p>
<blockquote>
<p>总结:</p>
<p>重点是可行、极小元的概念，还有元素的分解。</p>
</blockquote>
]]></content>
      <categories>
        <category>习题</category>
        <category>凸优化</category>
      </categories>
      <tags>
        <tag>凸优化</tag>
        <tag>习题</tag>
      </tags>
  </entry>
  <entry>
    <title>凸集/凸函数习题</title>
    <url>/2019/06/18/%E5%87%B8%E9%9B%86%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<p>《凸优化》第二/三章部分习题。</p>
<a id="more"></a> 
<h3 id="2-9"><a href="#2-9" class="headerlink" title="2.9"></a>2.9</h3><p>(a) 证明：</p>
<p>​    考虑 </p>
<script type="math/tex; mode=display">
V_i=\{x=\textbf{R}^n\mid \|x-x_0\|_2\leq\|x-x_i\|_2\}</script><p>作超平面 $(x_i-x_0)^Tx=(x_i-x_0)^T(x_i+x_0)/2$</p>
<p>​    对超平面上每个点 $x<em>k$ 的分量 $j$ 都有 $2(x</em>{ij}-x<em>{0j})x</em>{kj}=(x<em>i^2-x_0^2)$ ，且 $|x_k-x_0|_2=\sqrt{\sum_j{(x</em>{kj}-x<em>{0j})^2}}$  ，$|x_k-x_i|_2=\sqrt{\sum_j{(x</em>{kj}-x_{0j})^2}}$ 。</p>
<p>​    将第一式带入范数表达式可得对超平面上每个点 $x$ 均有 $|x-x_0|_2=|x-x_i|_2$ ，且对于超平面下方的半空间 $(x_i-x_0)^Tx\leq(x_i-x_0)^T(x_i+x_0)/2$ ，均有 $|x-x_0|_2\leq |x-x_i|_2$ ，对所有的 $i$ 均成立。即 $V$ 的边界为一系列超平面的交，$V$ 为多面体。设 $x_i-x_0=a_i$ ，$(x_i-x_0)^T(x_i+x_0)/2=b_i$ ， $V$ 可以被写作 </p>
<script type="math/tex; mode=display">
V=\{x\mid Ax\preceq b\}, A=\{a_1^T,a_2^T,\cdots,a_K^T\}, b=\{b_1,b_2,\cdots,b_K\}</script><p>(b)</p>
<p>​    P总可以表达为$P={x\mid Ax\preceq b}$ 的形式，设 $A={a_1^T,a_2^T,\cdots,a_K^T}$ ，对于任意一点 $x_0\in P$ 和多面体的面 $a_i^Tx=b$，总可以找到直线 $x=x_0+ka_i, k\in\textbf{R}$ 上的一点 $x_i$ 满足对面上任意一点 $x_k$ ，有 $ |x_i-x_k|_2=|x_0-x_k|_2$ (作点 $x_0$ 关于面的对称点即可) ，这是由于 $x_0$ 在多面体内部，满足 $a^T_ix&lt;b$ ，在直线上增大 $k$ 会使 $|x_i-x_k|_2$ 减小至0后增大，使 $|x_0-x_k|_2$ 增大。根据定义，这样的一组点就$x_0, x_1,\cdots,x_K$ 满足 $P$ 是 $x_0$ 关于 $x_1,\cdots, x_K$ 的 Voronoi 区域。</p>
<p>(c)</p>
<p>​    并不总可以用 Voronoi 区域表示。最明显的例子是由数个无限边界多面体组成的集合，考虑 $\textbf{R}^2$ 中由三个多面体组成的集合，他们的边界超平面的法向量共面，且边界两两之间夹角小于90°，这样就有至少一个多面体真包含了一个半空间，记为A。依照之前 Voronoi 区域点的找法， $x_1,x_2,x_A$ 分属三个多面体且需要互相关于边界超平面对称，将其他两个多面体沿边界对称投影到A上，它们的交集就是 $x_A$ 的取值范围(因为 $x_A$ 需要同时与 $x_1,x_2$ 关于两条边界对称)。由于 A 真包含了一个半空间，所以两部分投影不可能有交集，即不可能找到这样的 $x_A$ 。</p>
<blockquote>
<p>总结：</p>
<p>主要是超平面的定义。</p>
</blockquote>
<h3 id="2-26"><a href="#2-26" class="headerlink" title="2.26"></a>2.26</h3><p>证明： </p>
<p>​    先证必要性。因为 $C=D$ ，即 $C\subseteq D, D\subseteq C$ ， ，显然它可以推得于 $S_C\leq S_D, S_D\leq S_C$， 即 $S_C=S_D$ 。</p>
<p>  再证充分性。因为 $S_C=S_D$，设 $C\neq D$ ，不失一般性，设存在 $x_i\in C, x_i\notin D$ ，<br>根据凸集定义，取 $D$ 的支撑超平面集，一定存在某个方向 $a^T$ 上的 $D$ 的支撑超平面，满足 $a^Tx_i&gt;b$ 且 $\forall x \in D, a^Tx&lt;b$ 。<br>  将 $a$ 取为支撑函数自变量，则 </p>
<script type="math/tex; mode=display">
S_C(a)=\sup\{a^Tx\mid x\in C\}=a^Tx_i >b> \sup\{a^Tx\mid\ x\in D\}</script><p>  即 $S_C\neq S_D$ ，矛盾。所以 $C=D$ 。</p>
<blockquote>
<p>总结：</p>
<p>这道题说明了一个性质，即凸集能被他们的支撑函数完全表征，它们是双射关系。考虑”支撑集”定义和支撑一词的含义，能够表征凸集还是比较容易理解的。</p>
</blockquote>
<h3 id="2-33"><a href="#2-33" class="headerlink" title="2.33"></a>2.33</h3><p>(a) 证明:</p>
<p>​    $K<em>{m+}$ 在 $\textbf{R}^n$ 中由 n 个带等号不等式约束，所以其是闭凸集，且容易知道它满足 $\theta_1 x_1+\theta_2 x_2\in K</em>{m+}, \forall x<em>1,x_2\in K</em>{m+}$ 所以 $K<em>{m+}$ 是个闭凸锥。其内部非空性质通过列举满足条件的向量同样易得。<br>​    因为 $x\in K</em>{m+}, -x\in K<em>{m+}$ ，即 $x_1\geq x_2\geq\cdots\geq x_n\geq 0, x_1\leq x_2\leq\cdots\leq x_n\leq 0$ ，即 $x_1=x_2=\cdots=x_n=0$ ， $x=0$ 。所以 $K</em>{m+}$ 是尖的，所以它是正常锥。</p>
<p>(b) </p>
<script type="math/tex; mode=display">
K^*_{m+}=\{y\mid\sum x_iy_i\geq0, \forall x\in K\}\\</script><p>注意到提示中恒等式，有</p>
<script type="math/tex; mode=display">
\begin{align}
K^*_{m+}&=\{y\mid (x_1-x_2)y_1+(x_2-x_3)(y_1+y_2)+
(x_3-x_4)(y_1+y_2+y_3)\\&+\cdots+(x_{n-1}-x_n)(y_1+\cdots+y_{n-1})+x_n(y_1+\cdots+y_n)\geq0, \forall x\in K\}\\
K^*_{m+}&=\{y\mid\sum_{i=1}^n y_i\geq 0\}
\end{align}</script><blockquote>
<p>总结：</p>
<ul>
<li>等号不等式约束集为闭凸集。</li>
</ul>
</blockquote>
<h3 id="3-9"><a href="#3-9" class="headerlink" title="3.9"></a>3.9</h3><p>(a) 证明:</p>
<p>$\overset{-}{f}$ 为凸的二阶条件是 $\triangledown^2\overset{-}{f}$ 半正定。<br>即 $\bigtriangledown^2\overset{-}{f}(z)=F^T\bigtriangledown^2f(Fz+\hat{x})F\succeq 0$ </p>
<p>(b) 证明：</p>
<p>即证明 $F^T\bigtriangledown^2(Fz+\hat{x})F\succeq 0 \Leftrightarrow \bigtriangledown^2 f(Fz+\hat{x})+\lambda A^TA\succeq 0$<br>使用引理：</p>
<blockquote>
<p>总结：</p>
<p>这里没有写，但最后交上去的时候这里还是写了的，实际上这里是应用 (a) 中的结论， 将 $F$ 分解后仍然成立，即$\forall v,v^T\triangledown^2f(Fz+\hat{x})v\succeq0$ 。 $v$ 也在 $A$ 的零空间中。然后直接用引理就行。 用 $B=\triangledown^2f(Fz+\hat{x})$ 代换引理的话，很容易就能得出结论。</p>
<p>还需要注意一点是 $g(x)=f(Ax+b)$ 的二阶条件是 $\triangledown^2g$ 和 $A^T\triangledown^2fA$ 。</p>
</blockquote>
<h3 id="3-35"><a href="#3-35" class="headerlink" title="3.35"></a>3.35</h3><p>(a)证明：</p>
<p>$S<em>B(y)=\sup{y^Tx\mid x\in B}$， $S</em>{\textbf{conv}B}(y)=\sup{y^Tx’\mid x’\in\textbf{conv}B}$ </p>
<p>因为 $B\subseteq\textbf{conv}B$ ，所以在 $y$ 确定时 ， 有 $y^Tx\leq y^Tx’$ 。在 $y$ 确定的情况下，若此不等式不能取严格等号，则必定存在某个 $x’$ 对任意 $x$ 都取 </p>
<script type="math/tex; mode=display">
y^Tx<y^Tx'</script><p>根据凸包定义，$x’=\sum_i\theta_i x_i, \sum\theta_i=1, x_i\in B$ ，则有 </p>
<script type="math/tex; mode=display">
y^Tx'=y^T\sum\theta_i x'>y^T\sum\theta_i x_i=y^Tx_i</script><p>矛盾。所以不等式可以严格取等号，即 $S<em>B(y)=S</em>{\textbf{conv}B}(y)$</p>
<p>(b)证明：</p>
<script type="math/tex; mode=display">
\begin{align}
S_{A+B}(y)&=\sup\{y^Tx\mid x\in A+B\}=\sup\{y^T(a+b)\mid a\in A, b\in B\}\\
&=\sup\{y^Ta\mid a\in A\}+\sup\{y^Tb\mid b\in B\}\\
&=S_A(y)+S_B(y)
\end{align}</script><p>(c)证明：</p>
<script type="math/tex; mode=display">
\begin{align}
S_{A\cup B}(y)&=\sup\{y^Tx\mid x\in A\cup B\}\\
&=\max\{\sup\{y^Tx\mid x\in A\}, \sup\{y^Tx\mid x\in B\}\}\\
&=\max\{S_A(y)+S_B(y)\}
\end{align}</script><p>(d)证明:</p>
<p>必要性易得，此处仅证充分性：</p>
<script type="math/tex; mode=display">
S_{\textbf{conv}A}(y)=S_A(y)\leq S_B(y)</script><p>若 $\textbf{conv}A\nsubseteq B$，即 $\exists x\in \textbf{conv}A, x\notin B$ ，则 $S<em>{\textbf{conv}A\cup B}(y)&gt;S_B(y)$ 。又有 $S</em>{\textbf{conv}A\cup B}(y)=\max{S_{\textbf{conv}A}(y), S_B(y)}=S_B(y)$ 矛盾。所以 $A\subseteq \textbf{conv}A \subseteq B$。</p>
<blockquote>
<p>总结：</p>
<p>和2.26一样，结合之前的支撑函数的例子和此题（尤其是(a)），能更好地理解支撑函数能够表征凸集的性质。这种一一对应关系由sup运算保证。</p>
</blockquote>
<h3 id="3-38"><a href="#3-38" class="headerlink" title="3.38"></a>3.38</h3><p>证明:</p>
<p>即证明 $F(x)=\underset{y\in\textbf{dom}G}{\sup}(xy-G(y))$ 。</p>
<p>Young 不等式的简单图示:</p>
<p>可以看到 $xy$ 表征一个矩形面积，可以看到阴影面积和（即 $F(x)+G(y)$）永远不小于这个矩形面积，等号在 $f(x)=y$ 时取得。因为 $xy\leq F(x)+G(y)$ ，所以 $F(x)\geq xy-G(y)$ 。因为 $y=f(x)$ 时不等式可以取等号，所以$F(x)=\underset{y\in\textbf{dom}G}{\sup}(xy-G(y))$</p>
<blockquote>
<p>总结</p>
<p>此处无图，自行想象哈。大概就是函数过零点的函数 $f(x)$ 对 $x$ 轴和 $y$ 轴分别做 $[0,x],[0,y]$ 上的积分，这样可以把两个函数的定积分画到一个图上。</p>
</blockquote>
<h3 id="3-49"><a href="#3-49" class="headerlink" title="3.49"></a>3.49</h3><p>(a) 证明：</p>
<script type="math/tex; mode=display">
\begin{align}
\ln f(x)=\ln\frac{e^x}{1+e^x}=x-\ln (1+e^x)
\end{align}</script><p>其中 $x$ 是凹函数而 $-\ln(1+e^x)$ 可以看做指数和的对数取负，它是凹函数函数。所以原式是对数凹的。</p>
<p>(b) 证明：</p>
<script type="math/tex; mode=display">
\begin{align}
\ln f(x)=-\ln\sum\frac{1}{x_i}
\end{align}</script><p>因为 $1/x<em>i$ 在 $x\in\textbf{dom}f=\textbf{R}^n</em>{++}$ 上为凸函数，所以 $\sum 1/x_i$ 为其非负加权求和，也是凸函数。 $-\ln(x)$ 在定义域内为凸函数且非增。需要对复合函数求二阶导：</p>
<script type="math/tex; mode=display">
\begin{align}
h(x)&=-\ln\sum\frac{1}{x_i}\\
h'(x)&=
\end{align}</script><p>(c) 证明：</p>
<script type="math/tex; mode=display">
\begin{align}
\ln f(x)=\ln x_i-\ln\sum x_i

\\
f[\theta x+(1-\theta)y]=\frac{\prod[\theta x_i+(1-\theta) y_i]}{\sum[\theta x_i+(1-\theta) y_i]}\\
\frac{\prod[x_i^\theta y_i^{1-\theta}]}{(\sum x_i)^\theta(\sum y_i)^{1-\theta}}
\end{align}</script><p>(d) 证明：</p>
<script type="math/tex; mode=display">
\begin{align}
f(\theta X+(1-\theta)Y)=\frac{\det [\theta X+(1-\theta)Y]}{\textbf{tr}[\theta X+(1-\theta)Y]}\\
\frac{(\det X)^\theta(\det Y)^{1-\theta}}{\textbf{tr}X^\theta\textbf{tr}Y^{1-\theta}}
\end{align}</script><blockquote>
<p>总结：</p>
<p>实在做不下去了。。可以说一下答案大概的思路。</p>
<p>(b)考虑取 $\log$ 后的二阶条件，直接通过暴力（也没多暴力）算对 $x_i$ 的二次偏导和 $x_i,x_j$ 的联合偏导 ，这样可以直接写出整个 Hessian 阵的项，可以通过柯西施瓦茨不等式得出二阶条件为为负。</p>
<p>(c)有点麻烦按下不表。主体方法还是通过代入 $x+tv$ 的方式。</p>
<p>(d)同样考虑 $X=Z+tV$ ， $Z\succ 0$ 且对  $Z^{-1/2}VZ^{-1/2}$ 做特征值分解。主要行了一个比较难的代换：</p>
<script type="math/tex; mode=display">
\begin{align}
h(Z+tV)=\log f(Z+tV)&=\log\det(Z+tV)-\log\textbf{tr}(Z+tV)\\
&=\log\det Z-\log\det(I+tZ^{-1/2}VZ^{-1/2})-\\
&\ \ \ \ \log\textbf{tr}(Z(I+tZ^{-1/2}VZ^{-1/2}))
\end{align}</script><p>并用到了(c)中的条件。</p>
</blockquote>
]]></content>
      <categories>
        <category>习题</category>
        <category>凸优化</category>
      </categories>
      <tags>
        <tag>凸优化</tag>
        <tag>习题</tag>
      </tags>
  </entry>
  <entry>
    <title>对偶习题</title>
    <url>/2019/06/18/%E5%AF%B9%E5%81%B6%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<p>《凸优化》第五章部分习题</p>
<a id="more"></a>
<h3 id="5-6"><a href="#5-6" class="headerlink" title="5.6"></a>5.6</h3><p>(a)</p>
<script type="math/tex; mode=display">
\begin{align}
&\because\forall z\in\textbf{R}^m, \|z\|_\infty\geq\frac{1}{\sqrt{m}}\|z\|_2\\
&\therefore \|Ax_{ch}-b\|_2\leq\sqrt{m}\|Ax_{ch}-b\|_\infty\\
&\because \|Ax_{ch}-b\|_2\geq\|Ax_{ls}-b\|_2\text{(optimal)}\geq\|Ax_{ls}-b\|_{\infty}\text{(hint)}\\
&\therefore \|Ax_{ls}-b\|_\infty\leq \sqrt{m}\|Ax_{ch}-b\|_{\infty}
\end{align}</script><p>(b)</p>
<p>容易得到 $|\hat\nu|_1\leq1$ ，$|\tilde{\nu}|_1\leq1$ 。</p>
<script type="math/tex; mode=display">
\begin{align}
A^T\hat{\nu}&=(A^TAx_{ls}-A^Tb)/\|b-Ax_{ls}\|_1\\
&=(A^TA(A^TA)^{-1}A^Tb-A^Tb)/\|b-Ax_{ls}\|_1\\
&=0\\
A^T\tilde{\nu}&=-A^T\hat{\nu}=0
\end{align}</script><p> 即两个 $\nu$ 都是问题的可行解。考虑 $b^T\nu$：</p>
<script type="math/tex; mode=display">
\begin{align}
b^T\hat\nu&=\frac{-b^Tr_{ls}}{\|r_{ls}\|_1}=\frac{x_{ls}^TA^Tr_{ls}-b^Tr_{ls}}{\|r_{ls}\|_1}=-\frac{\|r_{ls}\|^2_2}{\|r_{ls}\|_1}\\
b^T\tilde\nu&=-b^T\hat\nu=\frac{\|r_{ls}\|^2_2}{\|r_{ls}\|_1}\\
\end{align}</script><p>即 $\tilde{\nu}$ 给出了更好（大）的下界。和(a)相比:</p>
<script type="math/tex; mode=display">
\begin{align}
\frac{\|r_{ls}\|^2_2}{\|r_{ls}\|_1}=\frac{\|Ax_{ls}-b\|^2_2}{\|b-Ax_{ls}\|_1}\geq\frac{\|Ax_{ls}-b\|^2_2}{\sqrt{m}\|b-Ax_{ls}\|_2}\geq\frac{\|Ax_{ls}-b\|_\infty}{\sqrt{m}}
\end{align}</script><p>比 (a) 给出了一个更好的下界。</p>
<blockquote>
<p>总结：</p>
<p>解是一些矩阵代换。不过这一题还给出了一个通过最小二乘问题等其他问题的对偶问题来逼近原问题最优解的方法。通常这类问题没有解析解，通过其他问题的对偶问题的分析得到的下界通常比一般不等式要好。</p>
</blockquote>
<h3 id="5-7"><a href="#5-7" class="headerlink" title="5.7"></a>5.7</h3><p>(a)</p>
<script type="math/tex; mode=display">
L(x,y,\nu)=\max_{i=1,\cdots,m} y_i+\sum_i\nu_i(a^T_ix+b_i-y_i)\\
g(\nu)=\inf_{x,y}(\max_{i=1,\cdots,m} y_i+\sum_i\nu_i(a^T_ix+b_i-y_i))</script><p>对偶问题：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{maximize } &g(\nu)\\
\text{subject to }&\nu\succeq 0
\end{align}</script><p>由于原函数有线性部分，考虑 $g(\nu)$：</p>
<p>优化 $x$ 时，$ \sum\nu^T a_i=0, i.e. A^T\nu=0$ 否则拉格朗日函数无下界。</p>
<p>优化 $y$ 时，$\max y_i-\nu^Ty=0$ 否则拉格朗日函数无下界，即 $v^T\textbf{1}=1$ 。</p>
<p>等价对偶问题：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{maximize } &\nu^Tb\\
\text{subject to }&\nu\succeq 0\\
&\nu^T\textbf{1}=1\\
&A^T\nu=0
\end{align}</script><p>(b)</p>
<p>原问题的上境图形式为LP：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{maximize } &t\\
\text{subject to }&\max(a_i^Tx+b_i)-t\leq 0
\end{align}</script><p>约束等价变换：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{maximize } &t\\
\text{subject to }&A_i^Tx+b_i-t\textbf{1}\preceq 0
\end{align}</script><p>对偶问题：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{maximize } &\lambda^Tb\\
\text{subject to }&A^T\lambda=0\\
&\lambda^T\textbf{1}=1\\
&\lambda\succeq0
\end{align}</script><p>和(a)中对偶问题完全等价。</p>
<p>(c)</p>
<p>考虑无约束几何规划对偶问题的最优解 $d^\star$ 以及其最优点 $z^\star$ ：</p>
<script type="math/tex; mode=display">
p^\star_{gp}\leq d^\star=b^Tz_i-\sum_iz^\star_i\log z^\star_i</script><p>将其变换成LP ，对某个 $\nu$ 有以下式子成立：</p>
<script type="math/tex; mode=display">
b^T\nu= p^\star_{gp} -\sum_iz^\star_i\log z^\star_i</script><p>又因为 $z^\star$ 在GP对偶问题上的可行域也是原分片线性极小化对偶问题的可行域，即 $z^\star$ 为此LP的可行解：</p>
<script type="math/tex; mode=display">
\begin{align}
p^\star_{pw1}&\geq b^T\nu=p^\star_{gp}-\sum_iz^\star_i\log z^\star_i\\
p^\star_{gp}-p^\star_{pw1}&\leq \sum_iz^\star_i\log z^\star_i\leq \log m
\end{align}</script><p>(d)</p>
<p>写出对偶问题，先变换问题为</p>
<script type="math/tex; mode=display">
\begin{align}
\text{maximize } &(1/\gamma)\log(\sum_i\exp(\gamma y_i))\\
\text{subject to }&Ax+b=y
\end{align}</script><p>拉格朗日函数：</p>
<script type="math/tex; mode=display">
L(x,\lambda)=(1/\gamma)\log\sum\exp(\gamma y_i)+\lambda^T(Ax+b-y)</script><p>$x$ 的最优化条件为 $A^T\lambda=0$ ，对 y 第一项为 Log-Sum-Exp 函数，其导数为 Softmax。即 $y$ 的最优化条件为：</p>
<script type="math/tex; mode=display">
\frac{e^{\gamma y_i}}{\sum e^{\gamma y_i}}=\lambda_i</script><p>对偶问题为：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{maximize } &\lambda^Tb-(1/\gamma)\sum_{i=1}^m\lambda_i\log\lambda_i\\
\text{subject to }&A^T\lambda=0\\
&\textbf{1}^T\lambda=1
\end{align}</script><p>按照处理(c)中GP对偶问题的步骤，第二项可以放缩为 $1/\gamma \log m$令其最优解为 $p^\star_{gp}(\gamma)-1/\gamma\log m$ 有：</p>
<script type="math/tex; mode=display">
p^\star_{gp}(\gamma)-1/\gamma\log m\leq p^\star_{pw1}\leq p^\star_{gp}(\gamma)</script><p>可看出 $\gamma $ 变大会让此优化问题逼近 $p^\star_{pw1}$ 。</p>
<blockquote>
<p>总结：</p>
<p>问题的拉格朗日对偶问题常常会因为保证满足优化时极小值可达所需要的条件，从而消去一些项使目标函数或约束变得简单 （拉格朗日对偶问题优化拉格朗日变量，对原问题优化变量直接取inf下界，化成等价问题时常常消去inf，即把原优化变量全部去掉），等价问题还可能直接优化成LP形式。(c)的解法比较技巧化，即通过辅助的LP问题分析，能用到之前分片线性极小化问题的性质。</p>
</blockquote>
<h3 id="5-16"><a href="#5-16" class="headerlink" title="5.16"></a>5.16</h3><p>(a)</p>
<p>因为 $f<em>0$ 凸， $f_i$ 凸，所以 $\max{0, f_i}$ 凸，所以 $\max</em>{i=1,\cdots,m}\max{0,f_i}$ 凸，所以 $\phi$ 凸。</p>
<p>(b)</p>
<script type="math/tex; mode=display">
\begin{align}
L(x,\lambda)&=f_0(x)+\sum_i\lambda_if_i(x)\\
g(\lambda)&=\inf_x(f_0(x)+\sum_i\lambda_if_ix(x))\\
L'(x,y,\lambda,\nu)&=f_0(x)+\alpha y+\sum_i\lambda_i(f_i(x)-y)-\nu y\\
g'(\lambda,\nu)&=\inf_{x,y}(f_0(x)+\alpha y+\sum_i\lambda_i(f_i(x)-y)-\nu y)\\
&=\inf_x(f_0(x)+\sum\lambda_if_i(x))+\inf_y((\alpha-\nu-\sum_i\lambda_i)y)
\end{align}</script><p>优化 $g’(\lambda,\nu)$ 的等价问题：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{maximize } &g(\lambda)\\
\text{subject to }&\textbf{1}^T\lambda-\alpha\leq0\\
&\lambda\succeq0\\
\end{align}</script><p>(c)</p>
<p>$\lambda^\star$ 为原对偶问题最优解： </p>
<script type="math/tex; mode=display">
\begin{align}
\text{maximize } &g(\lambda)\\
\text{subject to }
&\lambda\succeq0\\
\end{align}</script><p>辅助问题最优解 $x_s^\star\geq \lambda^\star_s$ ，且容易知道辅助问题对偶最优解 $ \lambda^\star_s$ 在原对偶问题上可行。又有 $\alpha&gt;\textbf{1}^T\lambda^\star$ ， 即 $\lambda^\star$ 也是辅助问题对偶最优解，两者可行域以及优化函数等价，辅助问题的最优解是其对偶问题最优解，由于原问题强对偶成立，所以对偶问题最优解也是原问题最优解，即：辅助问题的最优解也是原问题的最优解。</p>
<blockquote>
<p>总结：</p>
<p>比较常规的对偶分析。罚函数项和一些损失函数正则项有相似之处。</p>
</blockquote>
<h3 id="5-23"><a href="#5-23" class="headerlink" title="5.23"></a>5.23</h3><p>(a)</p>
<p>设不存在这样的 $z$ ，即 $-c\notin{\sum z_ia_i\mid z_i\geq0}$ ，右侧为闭凸集，根据严格分离超平面定理，存在超平面 $u^Tx$ 严格分离点和集合。即：</p>
<script type="math/tex; mode=display">
-u^Tc>\sum u^Tz_ia_i=u^TA^Tz</script><p>约束为 $z\succeq 0$ ，可以看出 $u^Tc&lt;0, u^TA^T&lt;0$ 。令 $x=x^\star+tu$ ：</p>
<script type="math/tex; mode=display">
a^T_ix=a^T_ix^\star+a^T_itu\leq b_i+ta^T_iu<b_i</script><p>即 $x$ 可行；考虑目标函数：</p>
<script type="math/tex; mode=display">
c^Tx=c^Tx^\star+tc^Tu<c^Tx^\star</script><p>我们找到了比 $x^\star$ 更优的解，矛盾。所以存在满足题意的 $z$ 。</p>
<p>(b)</p>
<p>对偶问题可行即 $-b\notin {Ax+s\mid s\succeq0}$ ，右侧为闭凸集，根据严格分离超平面定理，存在超平面 $v^Tx$ 严格分离点和集合。即：</p>
<script type="math/tex; mode=display">
-v^Tb>v^TAx+v^Ts</script><p>在 $x$ 任意取值下成立需要 $v^TA=0$ ， 等价式子为：</p>
<script type="math/tex; mode=display">
v^TA=0, v^Tb<0,v\succeq 0</script><p>那么对偶问题可行性条件 $A^Tz+c=0=A^T(z+v)$ ，即对偶问题在 $v$ 方向上是无界的， $d^\star =\infty$。</p>
<p>(c)</p>
<p>原问题容易看出不可行 ($0\leq -1$)，$p^\star=\infty$ 。</p>
<script type="math/tex; mode=display">
L(x,\lambda_1,\lambda_2)=x+\lambda_1(x-1)+\lambda_2</script><p>可行性条件 $\lambda_1+1=0$  ，对偶线性规划：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{maximize } &\lambda_2-\lambda_1\\
\text{subject to }&\lambda_1+1=0\\
&\lambda_1,\lambda_2\geq0\\
\end{align}</script><p>容易看出此问题约束  $\lambda_1=-1\geq0$ 不能满足，对偶问题不可行。$d^\star=-\infty$ 。</p>
<h3 id="5-27"><a href="#5-27" class="headerlink" title="5.27"></a>5.27</h3><p>拉格朗日函数：</p>
<script type="math/tex; mode=display">
\begin{align}
L(x,\nu)&=\|Ax-b\|^2_2+\nu^T(Gx-h)\\
&=x^TA^TAx-2b^TAx+b^Tb+\nu G^T x-\nu^Th\\
&=x^TA^TAx+(G^T\nu-2A^Tb)^Tx-\nu^Th+b^Tb
\end{align}</script><p>KKT条件:</p>
<script type="math/tex; mode=display">
2A^TAx^\star-2A^Tb+G^T\nu^\star=0\\
Gx^\star-h=0</script><p>最优解 $x^\star$ 可以用 $\nu^\star$ 显式表达：</p>
<script type="math/tex; mode=display">
x^\star=(\frac{1}{2}(A^TA)^{-1})(-G^T\nu^\star+2A^Tb)</script><p>代入 $Gx^\star-h=0, x^\star=G^{-1}h$ 后 $\nu^\star$ 可独立写出：</p>
<script type="math/tex; mode=display">
\nu^\star=(G^T)^{-1}(2A^Tb-2A^TAG^{-1}h)</script>]]></content>
      <categories>
        <category>习题</category>
        <category>凸优化</category>
      </categories>
      <tags>
        <tag>凸优化</tag>
        <tag>习题</tag>
      </tags>
  </entry>
  <entry>
    <title>ADMM 交替方向乘子法</title>
    <url>/2019/01/28/%E7%AC%94%E8%AE%B0-ADMM-%E4%BA%A4%E6%9B%BF%E6%96%B9%E5%90%91%E4%B9%98%E5%AD%90%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><a href="http://web.stanford.edu/~boyd/papers/pdf/admm_distr_stats.pdf">ADMM by Boyd, 2010</a></li>
<li>收敛速率和算法复杂度分析可见南大何教授的分析 <a href="http://maths.nju.edu.cn/~hebma/">主页</a></li>
<li>对于基础知识，建议简要阅读一下 Boyd 的凸优化。(Convex Optimization, Stephen Boyd)</li>
</ul>
<a id="more"></a>
<h2 id="等式约束优化问题"><a href="#等式约束优化问题" class="headerlink" title="等式约束优化问题"></a>等式约束优化问题</h2><h3 id="拉格朗日乘子法"><a href="#拉格朗日乘子法" class="headerlink" title="拉格朗日乘子法"></a>拉格朗日乘子法</h3><ul>
<li>即求 <script type="math/tex">\min f(x) \ \ s.t.g_i(x)=0</script><br>使用拉格朗日乘子 <script type="math/tex">\ L(x,\lambda)=f(x)+\sum\lambda_i g_i(x)</script> ，使 <script type="math/tex; mode=display">\frac{\partial L}{\partial x}=\frac{\partial L}{\partial \lambda_i}=0</script>可以得到最优解。</li>
<li>即多元微积分中求多元函数的条件极值。</li>
</ul>
<h3 id="罚函数"><a href="#罚函数" class="headerlink" title="罚函数"></a>罚函数</h3><ul>
<li>即求 <script type="math/tex">\min f(x) \ \ s.t.g_i(x)=0</script> 。<br>引入惩罚因子 $\sigma$ 与增广函数 $P$ ，有 <script type="math/tex">\min F(x,\sigma)=f(x)+\sigma P(x)</script><br>其中 $\sigma$ 取很大的正数， $P=g^T g$ 。增广函数指示偏离约束的程度，并由一个很大的惩罚因子给予惩罚。由此求解的极值几乎不会脱离约束。 </li>
</ul>
<h3 id="增广拉格朗日乘子法-Augmented-Lagrange-Method"><a href="#增广拉格朗日乘子法-Augmented-Lagrange-Method" class="headerlink" title="增广拉格朗日乘子法 Augmented Lagrange Method"></a>增广拉格朗日乘子法 Augmented Lagrange Method</h3><ul>
<li>在拉格朗日函数中引入罚函数，具体形式见后。</li>
</ul>
<h2 id="共轭问题和对偶问题"><a href="#共轭问题和对偶问题" class="headerlink" title="共轭问题和对偶问题"></a>共轭问题和对偶问题</h2><h3 id="共轭问题"><a href="#共轭问题" class="headerlink" title="共轭问题"></a>共轭问题</h3><ul>
<li>$f(x): R^n\rightarrow R$</li>
<li>$f^*(y): R^n\rightarrow R$</li>
<li>$f^*(y)=\sup_{x\in D}(y^Tx-f(x))$</li>
<li>(重要) <script type="math/tex">f^*(y)</script> 一定是凸的。这是因为逐点最大和逐点上确界操作是保凸的。在 <script type="math/tex">y\in R</script> 的情况下， <script type="math/tex">f^*</script> 相当于遍历仿射函数 <script type="math/tex">yx(kx)</script> 的斜率，并取 $kx+b$ 与 $f(x)$ 相交的时候最小的 $b$ ($b=-f(x)$)。</li>
<li>(重要) 若 $f$ 是凸的且可微，则使 $y^Tx-f(x)$ 取最大的 <script type="math/tex">x^*</script> 满足 <script type="math/tex">y=\triangledown f(x^*)</script>（遍历的仿射函数和 $f(x)$ 相切）。即，给定任意 $y$ ，可以求解梯度方程 $y=\triangledown f(z)$ 得到 $y$ 处共轭函数 $f^*(y)$</li>
<li>此处 $x$ 带有 $\sup$ 即要对 $x$ 做遍历，所以并不是常数。</li>
</ul>
<h4 id="拉格朗日对偶函数"><a href="#拉格朗日对偶函数" class="headerlink" title="拉格朗日对偶函数"></a>拉格朗日对偶函数</h4><ul>
<li>$g(\lambda,t)=\inf_{x\in D}L(x,\lambda,\nu)$</li>
<li>由于$\inf$的影响，$g$ 只能在一系列 $x$ 的取值中取最小的 $g(\lambda,\nu)$ 中取，是一族关于 $(\lambda,\nu)$ 的仿射函数的逐点下确界，是一定凸的。<br>所以对 $g(\lambda,\nu)=\min L(x,\lambda,\nu)\leq \min<em>x \max</em>{\lambda,\nu} L(x,\lambda,\nu)=\min f(x)$ 恒成立</li>
<li>拉格朗日对偶函数给出了优化问题的最优值的一个下界 <script type="math/tex">(d^*\leq p^*)</script></li>
</ul>
<h3 id="线性约束下两者关系"><a href="#线性约束下两者关系" class="headerlink" title="线性约束下两者关系"></a>线性约束下两者关系</h3><p>$\min f(x),s.t. Ax=a, Bx\leq b.$<br>$L(x,\lambda,t)=f(x)+\lambda(Ax-a)+\nu(Bx-b)$<br>对偶函数 $g(\lambda,\nu)=\inf<em>{x\in D} L(x,\lambda,\nu)=-\lambda a-\nu b-\sup</em>{x\in D}[(-\lambda A-\nu B)x-f(x)]$<br>$=-\lambda a-\nu b-f^*(-\lambda A-\nu B)$</p>
<h3 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h3><ul>
<li>$\max g(\lambda,\nu ),\ \ s.t.\ \ \lambda,\nu \geq 0.$</li>
<li>对偶问题的引出是因为 $g(\lambda,\nu)$ 描述一个最优值的下界，那么 $\max g(\lambda,\nu)$ 则是最优值的最好下界。</li>
<li>$\lambda,\nu$ 可代回 $L(x,\lambda,\nu)$ 对 $x$ 求 $\min L.$</li>
<li>此问题是无约束问题，拉格朗日方程不带约束项。这一过程消除了约束的限制(并入 $g$ 中)。且对偶问题一定是一个<strong>凸优化</strong>问题。</li>
<li>注意强对偶条件下对偶问题的解才和原问题解相同。凸优化问题满足Slater条件，即凸优化问题存在严格可行解（约束中的仿射函数不等式约束满足严格小于），问题具有强对偶性质。Slater条件确保原函数存在鞍点（？）。</li>
<li>凸问题下满足KKT条件的点 $\tilde{x},\tilde{\lambda},\tilde{\nu}$ ， $\tilde{x}$ 和 $(\tilde{\lambda},\tilde{\nu})$ 分别是原问题和对偶问题的最优解，且对偶间隙为0。</li>
</ul>
<h2 id="ADMM与相关优化算法"><a href="#ADMM与相关优化算法" class="headerlink" title="ADMM与相关优化算法"></a>ADMM与相关优化算法</h2><h3 id="对偶上升法-Dual-Ascent-Method"><a href="#对偶上升法-Dual-Ascent-Method" class="headerlink" title="对偶上升法 Dual Ascent Method"></a>对偶上升法 Dual Ascent Method</h3><ul>
<li>使用梯度上升法更新 $\lambda$ 和 $\nu$ 。不断迭代求对偶问题的最优解（最大值，故用上升法）。每次更新 $\lambda$ 和 $\nu$ 都可以从此带入 $L$ 求出一个新的 $x$ ，此时得到一条新曲线（也可能是原曲线，但永远不会在原曲线上方），可以得到新的对偶问题继续更新 $\lambda$ 和 $\nu$ 。</li>
<li><p>$\lambda, \nu$ 的上标表示迭代次数，在迭代中不断将解更新为满足不同约束条件的解。(剩余约束条件是多余的)(等式约束对所有可行解都是起作用的)</p>
</li>
<li><p>原问题：$\min f(x) \s.t. Ax=b$<br>其拉格朗日函数为：</p>
<script type="math/tex; mode=display">L(x,\lambda)=f(x)+\lambda^T(Ax-b)</script><p>对偶函数为：</p>
<script type="math/tex; mode=display">
\begin{align}
g(\lambda)&=\inf_x L(x,\lambda)=\inf_x (f(x)+\lambda^T(Ax-b))\\&=-\sup_x (-f(x)-\lambda^TAx)-\lambda^Tb\\&=-f^※(-A^T\lambda)-b^T\lambda
\end{align}</script><p>对偶问题：$\max g(\lambda)$<br>在强对偶条件成立的情况下，原问题最优解(minimizer) <script type="math/tex">x^*</script> 可以通过 <script type="math/tex">y^*</script> (即上述 <script type="math/tex">\lambda^*</script>) 使用下式计算：<br><script type="math/tex">x^*=\arg\min_x L(x,\lambda^*)</script> 。</p>
</li>
<li><p>若 $g$ 可微，对任意点 $(x,\lambda)$ ，令（有?） $x^+=\arg\min_xL(x,y)$ ,则其梯度 $\triangledown g(y)=Ax^+-b$ ，则点的迭代（即梯度上升迭代）式如下：</p>
<script type="math/tex; mode=display">
\begin{align}
x^{k+1}&:=\arg\min_x L(x,y^k)\\
y^{k+1}&:=y^k+\alpha^k(Ax^{k+1}-b)
\end{align}</script><p>利用梯度上升迭代更新对偶问题的答案 $y$ ，并用 $y$ 反过来更新 $x$ 。 $\alpha^k&gt;0$ 是步长，所有上标都为迭代计数器。</p>
</li>
<li><p>若 $f$ 为 $x$ 的任何分量的非零仿射函数，则 $x$ 无法更新，因为大多数情况下 $L$ 对 $x$ 无界（例 $y=kx+b$ 在 $k\neq0$ 时 $y$ 无下界）。</p>
</li>
</ul>
<h4 id="对偶分解法-Dual-Decomposition"><a href="#对偶分解法-Dual-Decomposition" class="headerlink" title="对偶分解法 Dual Decomposition"></a>对偶分解法 Dual Decomposition</h4><ul>
<li>对 $x$ 的更新可以并行执行。</li>
</ul>
<h3 id="增广拉格朗日乘子法-Augmented-Lagrange-Method-1"><a href="#增广拉格朗日乘子法-Augmented-Lagrange-Method-1" class="headerlink" title="增广拉格朗日乘子法 Augmented Lagrange Method"></a>增广拉格朗日乘子法 Augmented Lagrange Method</h3><ul>
<li>在拉格朗日函数中引入二次罚函数因子（即二次正则项，设约束为线性约束） <script type="math/tex; mode=display">L_\rho(x,y)=f(x)+y^T(Ax-b)+(\rho/2)||Ax-b||^2_2</script></li>
<li>迭代过程：<script type="math/tex; mode=display">
\begin{align}
x^{k+1}&:=\arg\min_x L_\rho(x,y^k)\\
y^{k+1}&:=y^k+\rho(Ax^{k+1}-b)
\end{align}</script></li>
<li>由于二次惩罚项的存在无法并行更新 $x$</li>
</ul>
<h3 id="交替方向乘子法-Alternating-Direction-Method-of-Multipliers"><a href="#交替方向乘子法-Alternating-Direction-Method-of-Multipliers" class="headerlink" title="交替方向乘子法 Alternating Direction Method of Multipliers"></a>交替方向乘子法 Alternating Direction Method of Multipliers</h3><h4 id="ADMM-基本形式-Unscale-form"><a href="#ADMM-基本形式-Unscale-form" class="headerlink" title="ADMM 基本形式(Unscale form)"></a>ADMM 基本形式(Unscale form)</h4><ul>
<li>ADMM将原来的变量 $x$ 分成 $x$ 和 $z$ 两部分。优化问题如下（一次等式约束）：<script type="math/tex; mode=display">\min f(x)+g(z)\\ s.t. Ax+Bz=c</script></li>
<li>最优值可表示为(?)：<script type="math/tex; mode=display">p^*=\inf\{f(x)+g(z)\ |\ Ax+Bz=c\}</script></li>
<li>其拉格朗日函数可表示为：<script type="math/tex; mode=display">L_\rho(x,z,y)=f(x)+g(z)+y^T(Ax+Bz-c)+(\rho/2)||Ax+Bz-c||^2_2</script></li>
<li>迭代过程：<script type="math/tex; mode=display">
\begin{align}
x^{k+1}&:=\arg\min_x L_\rho(x,z^k,y^k)\\
z^{k+1}&:=\arg\min_z L_\rho(x^{k+1},z,y^k)\\
y^{k+1}&:=y^k+\rho(Ax^{k+1}+Bz^{k+1}-c)
\end{align}</script></li>
<li>ADMM的可以并行迭代更新x,z</li>
</ul>
<h4 id="Scale-form"><a href="#Scale-form" class="headerlink" title="Scale form"></a>Scale form</h4><ul>
<li>定义残差(residual) $r=Ax+Bz-c$ 和 Scale dual variable $u=(1/\rho)y$ ，我们有<script type="math/tex; mode=display">y^Tr+(\rho/2)||r||^2_2=(\rho/2)||r+(1/\rho)y||^2_2-(1/2\rho)||y||^2_2</script>ADMM迭代式可以重写为：<script type="math/tex; mode=display">
\begin{align}
x^{k+1}&:=\arg\min_x (f(x)+(\rho/2)||Ax+Bz^k-c+u^k||^2_2)\\
z^{k+1}&:=\arg\min_z (g(x)+(\rho/2)||Ax^{k+1}+Bz-c+u^k||^2_2)\\
u^{k+1}&:=u^k+Ax^{k+1}+Bz^{k+1}-c
\end{align}</script>即为ADMM的Scale form</li>
</ul>
<h4 id="停止条件"><a href="#停止条件" class="headerlink" title="停止条件"></a>停止条件</h4><ul>
<li>原变量满足收敛条件时残差必定满足收敛于0的条件，所以可以取<script type="math/tex; mode=display">||r^k||_2\leq\epsilon^{pri}\ \ \ \ and\ \ \ \ ||s^k||_2\leq\epsilon^{dual}</script></li>
<li>其中的 $\epsilon$ 取法需满足一定条件，可见Boyd 2011论文式(3.12)部分。</li>
</ul>
<h4 id="对一般约束问题"><a href="#对一般约束问题" class="headerlink" title="对一般约束问题"></a>对一般约束问题</h4><ul>
<li>优化问题如下：<script type="math/tex; mode=display">\min f(x)\\ s.t. x\in \mathcal{C}</script>其中 $x\in R^n$ ，$f$ 和 $\mathcal{C}$ 都是凸的，转化为ADMM形式：<script type="math/tex; mode=display">\min f(x)+g(z)\\ s.t. x-z=0</script>其中 $g$ 是 $\mathcal{C}$ 的指示函数（即 $x\in \mathcal{C}$ 则 $g(x)=0$ ，否则 $g(x)=+\infty$<br>迭代式为：<script type="math/tex; mode=display">
\begin{align}
x^{k+1}&:=\arg\min_x (f(x)+(\rho/2)||x-z^k+u^k||^2_2)\\
z^{k+1}&:=\Pi_C(x^{k+1}+u^k)\\
u^{k+1}&:=u^k+x^{k+1}-z^{k+1}
\end{align}</script>其中 $\Pi_{\mathcal{C}(x)}$ 即 $x$ 在集合 $\mathcal{C}$ 上的欧几里得投影。</li>
</ul>
<h4 id="对非凸问题"><a href="#对非凸问题" class="headerlink" title="对非凸问题"></a>对非凸问题</h4><ul>
<li>优化问题如下：<script type="math/tex; mode=display">\min f(x)\\ s.t. x\in S</script>其中 $f$ 凸而 $S$ 非凸，ADMM迭代式为：<script type="math/tex; mode=display">
\begin{align}
x^{k+1}&:=\arg\min_x (f(x)+(\rho/2)||x-z^k+u^k||^2_2)\\
z^{k+1}&:=\Pi_S(x^{k+1}+u^k)\\
u^{k+1}&:=u^k+x^{k+1}-z^{k+1}
\end{align}</script>对 $z$ 的更新由于 $S$ 的非凸性变得难以计算，但仍然有容易计算的特例存在：<ul>
<li>基数运算：<br>如果 <script type="math/tex">S=\{x| card(x)\leq c\}</script> ，其中 $card$ 给出集合中非零元的数量，那么 $\Pi_S(v)$ 是将 $v$ 的最大 $c$ 个元素保留并将其余元素置零。</li>
<li>秩运算：<br>如果 $S$ 是秩为 $c$ 的矩阵的集合，那么 $\Pi<em>S(v)$ 通过SVD计算并保留前 $c$ 对，即 $\Pi_S(v)=\sum^c</em>{i=1}\sigma_i u_i v_i^T$</li>
<li>布尔约束：<br>如果 $S={x|x<em>i\in{0,1}}$ ，那么 $\Pi<em>S(v)$ 直接取 0、1 中更近的那个。__整数约束</em></em>可以被同样的方式处理。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>凸优化</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>凸优化</tag>
      </tags>
  </entry>
  <entry>
    <title>PLS简介</title>
    <url>/2019/11/23/%E7%AC%94%E8%AE%B0-PLS%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<p>PLS 即 Partial Least Squares  偏最小二乘法。</p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>适用特点：数据量小、数据维数高、数据多重共线性</p>
</li>
<li><p>为什么？考虑回归问题 $y=\alpha +\beta X+\epsilon$ ，那么最小二乘回归（最大化X、y协方差）</p>
<script type="math/tex; mode=display">
  \beta=(X'X)^{-1}X'y</script><p>即需要 $X’X$ 可逆满秩，$X$ 的样本（行数）需要多于特征（列数），且特征之间没有线性相关性（共线性）。</p>
</li>
<li><p>对比：</p>
<ul>
<li><p>PCA：</p>
</li>
<li><script type="math/tex; mode=display">
X=TP'=T_kP_k'+E\\</script><p>使用SVD求：</p>
</li>
<li><script type="math/tex; mode=display">
X=USV',T=US,P=V,X=TP'</script><p>但是PCA没有利用预测信息即 $y$ ，有些PC和预测没有关系。</p>
</li>
</ul>
</li>
<li><p>PLS模型：</p>
</li>
<li><script type="math/tex; mode=display">
X=TP'+E\\
Y=UQ'+F</script><p>其中 $X$ 为 $n×m$ 观测矩阵，$Y$ 为 $n×p$ 响应矩阵。$T/U$ 为 $n×l$ 的得分矩阵（或成分矩阵），$P/Q$ 为 $m/n ×l$ 的正交载荷矩阵，$E/F$ 为残差。</p>
</li>
<li><p>要求：$\max \text{Cov}(T,U)$ 。类似PCR，观测矩阵被分解为得分矩阵和载荷矩阵的外积，但是PCR中 $X=TP’, T=XW, P=W$ 即权值和载荷相同，这一点不同于PLS（ PLS1中 $w=X’y$ ，正比于X和y的协方差）。</p>
</li>
</ul>
<hr>
<ul>
<li>PLS-CV：<img src="https://s2.ax1x.com/2020/03/09/8SgFJJ.png" alt="image-20191211162109235"></li>
</ul>
<hr>
<h2 id="PLS-算法"><a href="#PLS-算法" class="headerlink" title="PLS 算法"></a>PLS 算法</h2><h3 id="NIPALS"><a href="#NIPALS" class="headerlink" title="NIPALS"></a>NIPALS</h3><ol>
<li><p>令 $X_a, Y_a$ 为观测矩阵和响应矩阵</p>
</li>
<li><p>数据标准化：</p>
</li>
</ol>
<ul>
<li>观测/响应矩阵需要减去对应维度的均值</li>
<li>一般没有除以标准差这一操作</li>
</ul>
<ol>
<li><p>取其中一列 $y$ 作为 $u_1$ （因子）</p>
</li>
<li><p>计算 $X$ 权重：（利用 $u_1$ 信息，用权重实现 $X$ 到因子 $t$ 的变换）</p>
</li>
</ol>
<script type="math/tex; mode=display">
w_1=\frac{X'_{0}u_{1}}{u_1'u_1}\\
w_1\leftarrow \frac{w_1}{\|w_1\|}</script><ol>
<li>计算得分向量（因子）：</li>
</ol>
<script type="math/tex; mode=display">
t_1=X_{0}w_1</script><ol>
<li><p>对 $Y$ 进行相同操作，求得权重 $c_1$ ，因子 $u_1^*$ ，计算 $u$ 的残差是否收敛</p>
</li>
<li><p>计算载荷向量（$p$ 反映 $X$ 和 $t$ 的关系，估计意义上 $X=tp’$：</p>
</li>
</ol>
<script type="math/tex; mode=display">
p_1=X_0'\frac{t_1}{t_1't_1}\\
    q_1=Y_{0}'\frac{u_1}{u_1'u_1}\\</script><ol>
<li>计算新观测矩阵（残差矩阵）：</li>
</ol>
<script type="math/tex; mode=display">
X_1=X_{0}-t_1p_1'\\
b_1=u_1't_1/t_1't_1\\
Y_1=Y_{0}-u_1q_1'=Y_0-b_1t_1q_1'</script><ol>
<li><p>循环</p>
</li>
<li><p>若为回归任务，则任务目标是回归线性模型 $Y=\alpha+X\beta +\epsilon$ ，则 </p>
</li>
</ol>
<script type="math/tex; mode=display">
\hat{\beta}=W(P'W)^{-1}q\\
\hat{\alpha}=\overline{y}-\overline{x}\hat{\beta}</script><p>​                否则需解：</p>
<ul>
<li><script type="math/tex; mode=display">
M=X_{a-1}'Y_{a-1}Y_{a-1}'X_{a-1}</script><p>其最大特征值为 $\theta_a^2$，单位特征向量为 $w_a$ ， $v_a$ 可由其计算得出。</p>
</li>
<li><p>第一轮之后的权重把残差变换到因子，不对原始数据变换</p>
</li>
</ul>
<h3 id="SIMPLS"><a href="#SIMPLS" class="headerlink" title="SIMPLS"></a>SIMPLS</h3><p>$S=X_0’Y_0$</p>
<p>for i=1 to k</p>
<p>​    if i=1: $[u,s,v]=SVD(S)$</p>
<p>​    if i&gt;1: $[u,s,v]=SVD(S-P<em>{i-1}(P</em>{i-1}’P<em>{i-1})^{-1}P’</em>{i-1}S)$</p>
<p>​    $r_i=u(:,1)$</p>
<p>​    $t_i=X_0r_i$</p>
<p>​    $p_i=X’_0t_i/t_i’t_i$</p>
<p><code>end</code></p>
<p>$B_{PLS}=R_k(T_k’T_k)^{-1}T_kY_0$</p>
<h3 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h3><ul>
<li>NIPALS的权重是相对于各个残差矩阵而言的，解释不便</li>
<li>SIMPLS更快，且是Matlab 标准算法</li>
<li>大部分情况下结果相似，但是高 latent variable 时 SIMPLS 不稳定</li>
</ul>
<p><img src="https://s2.ax1x.com/2020/03/09/8pQcJH.png" alt="image-20191213141042111"></p>
<hr>
<h2 id="Kernel-PLS"><a href="#Kernel-PLS" class="headerlink" title="Kernel PLS"></a>Kernel PLS</h2><ul>
<li>解决非线性问题，和SVM一样可以采用 Kernel 方法：将非线性的低维数据投影到高维后数据变得线性。核函数则用来计算数据在高维空间中的内积。</li>
<li>实验中由于映射未知，核函数无法显式推导，一般只能通过枚举实验。</li>
</ul>
<hr>
<h2 id="PLS分类"><a href="#PLS分类" class="headerlink" title="PLS分类"></a>PLS分类</h2><ul>
<li>PLS-DA</li>
<li>通过 dummy matrix 对响应矩阵编码（类似 one-hot）来分类</li>
<li>处理非线性问题，类别不平衡问题性能会下降</li>
<li>Local weighted PLS：对每个待预测的query，只选出一部分最近的训练样本进行回归建模（多个线性模型来处理非线性）</li>
</ul>
<hr>
<h2 id="Variable-Selection"><a href="#Variable-Selection" class="headerlink" title="Variable Selection"></a>Variable Selection</h2><p><img src="https://s2.ax1x.com/2020/03/09/8SgKoD.png" alt="image-20191212213245596"></p>
<ul>
<li>filter方法，直接从输出中过滤</li>
<li>wrapper：基于filter，选出的变量送回模型重新拟合</li>
<li>embedded的方法，顾名思义即变量选择是PLSR过程的一部分</li>
</ul>
<ul>
<li>loading weight：可以直接用此向量衡量变量重要性</li>
<li>regression coefficients</li>
<li>variable importance in projection</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>机器学习</category>
        <category>多元回归</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch 问题汇总</title>
    <url>/2019/11/23/%E7%AC%94%E8%AE%B0-Pytorch%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>记录一些自己遇到的有关 PyTroch 的问题。</p>
<a id="more"></a>
<h3 id="关于Mask梯度的方法"><a href="#关于Mask梯度的方法" class="headerlink" title="关于Mask梯度的方法"></a>关于Mask梯度的方法</h3><ul>
<li>自己尝试过两种实现方式：<ul>
<li>模型 layer 使用自定义的 <code>MaskedConv</code> 等 layer 实现，layer中自带一个mask的tensor，在 <code>init()</code> 中定义 <code>backward_hook(grad)</code> ，并在其中执行 <code>register_hook()</code> 。之后只要改动 mask就好；</li>
<li>不改动模型，在训练结束后手动添加 <code>layer.mask</code>，手动<code>register_hook()</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="关于数组-Index"><a href="#关于数组-Index" class="headerlink" title="关于数组 Index"></a>关于数组 Index</h3><ul>
<li>Pytorch 1.3之后如果要使用 <code>Tensor_1[Tensor_2]</code> 的写法，Tensor_2的dtype必须是<code>torch.bool</code>(以前可以是uint8)，不然会疯狂报错。正确写法 <code>Tensor_1[Tensor_2.bool()]</code></li>
<li>此类错误不会给出traceback。手动开启traceback方法：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">warn_with_traceback</span>(<span class="params">message, category, filename, lineno, file=<span class="literal">None</span>, line=<span class="literal">None</span></span>):</span></span><br><span class="line"></span><br><span class="line">    log = file <span class="keyword">if</span> <span class="built_in">hasattr</span>(file,<span class="string">&#x27;write&#x27;</span>) <span class="keyword">else</span> sys.stderr</span><br><span class="line">    traceback.print_stack(file=log)</span><br><span class="line">    log.write(warnings.formatwarning(message, category, filename, lineno, line))</span><br><span class="line"></span><br><span class="line">warnings.showwarning = warn_with_traceback</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="关于-backward"><a href="#关于-backward" class="headerlink" title="关于 backward"></a>关于 backward</h3><ul>
<li>需要一步内多次<code>backward()</code>的情况：<code>loss.backward(retain_graph=True)</code> 否则无法在之后再次 <code>loss.backward()</code>。注意此类型报错通常能以更高效的方式解决(?)</li>
</ul>
<hr>
<h3 id="关于-apply-fn"><a href="#关于-apply-fn" class="headerlink" title="关于 apply(fn)"></a>关于 apply(fn)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> module <span class="keyword">in</span> self.children():</span><br><span class="line">  module.apply(fn)</span><br><span class="line">fn(self)</span><br><span class="line"><span class="keyword">return</span> self</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="关于-tensor与numpy的转换"><a href="#关于-tensor与numpy的转换" class="headerlink" title="关于 tensor与numpy的转换"></a>关于 tensor与numpy的转换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = torch.ones[<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.numpy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">tensor([<span class="number">3.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])</span><br></pre></td></tr></table></figure>
<p>两者指向同一地址。</p>
<p>对b进行改动时应使用inplace操作，否则b地址会被替换。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = numpy.zeros_like([<span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = c</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">tensor([<span class="number">3.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.numpy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b += (c - b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>需要注意的是，显卡上的tensor（device=GPU）需要取到cpu上才能转换为numpy <code>A.cpu().numpy()</code> 否则报错。</li>
<li>还有一点是，注意维持其为同一个ndarray数组对象，否则仍然会替换地址(如 <code>b = 1</code> 则b不再和a共享地址)</li>
</ul>
<hr>
<h3 id="关于-copy-clone-detach-的区别"><a href="#关于-copy-clone-detach-的区别" class="headerlink" title="关于 copy_(), clone(), detach(), = 的区别"></a>关于 copy_(), clone(), detach(), = 的区别</h3><ul>
<li><p>后两者复制地址，detach不复制梯度</p>
</li>
<li><p>注意转换 <code>A.cpu().detach().numpy()</code> 所detach的是cpu上的临时tensor，不会对A (此时A的device是显卡) 造成任何影响，也不会对其他Tensor有影响。<code>A.cpu()</code> 是函数返回值，本身创造的临时tensor在创造完numpy数组后会被释放(大概吧)</p>
<p><del>所以需要重新 register_buffer</del> </p>
<p>不需要，用 <code>A.data.copy_(torch.as_tensor(A_np))</code> 。</p>
</li>
<li><p>在 <code>W.required_grad==True</code> 的情况下不能使用 <code>W.cpu().numpy()</code> ，必须detach()</p>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>笔记</category>
        <category>问题记录</category>
        <category>PyTorch</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>笔记</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Going Deeper With Directly-Trained Larger Spiking Neural Networks</title>
    <url>/2020/12/15/%E7%AC%94%E8%AE%B0-STBP-tdBN/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><a href="https://arxiv.org/abs/2011.05280">Going Deeper With Directly-Trained Larger Spiking Neural Networks - 原文</a> 。</li>
<li>个人理解：听起来和结果上都很厉害的工作。主要解决直接训练SNN算法中的各类Normalization的问题。如STBP这类算法因为是BPTT-inspired的，也会出现梯度消失和爆炸的现象。而且由于脉冲激活不可导，为了BP算法的应用通常都要引入梯度的近似，造成梯度更新有误差，带来了不稳定因素。同时由于信息在LIF模型中传输是“输入-电位-输出”的模型，信息需要在电位上周转一次。如果timestep低且发放率（firing rate）低，“电位-输出”这一环节就会被卡住，造成信息损失；如果脉冲发放率高，神经元的输出对输入就不敏感（实际上从编码的角度来看，firing rate无论是过低还是过高，其信息表达能力都很有限，从这个角度来看理想的发放率是0.5）。论文提出了适用于直接训练SNN算法的BN改进版，并且在残差网络上跑了ImageNet数据集，总的来说算是比较solid的，要是能开放源码就更solid了。</li>
</ul>
<a id="more"></a>
<h3 id="Iterative-LIF"><a href="#Iterative-LIF" class="headerlink" title="Iterative LIF"></a>Iterative LIF</h3><ul>
<li>迭代LIF模型，引自<a href="https://www.aaai.org/ojs/index.php/AAAI/article/view/3929">此文</a>。</li>
<li>STBP的基础。分析可见<a href="https://thiswinex.github.io/2020/11/23/%E7%AC%94%E8%AE%B0-STBP/">此处</a>。</li>
</ul>
<h3 id="Threshold-dependent-batch-normalization"><a href="#Threshold-dependent-batch-normalization" class="headerlink" title="Threshold-dependent batch normalization"></a>Threshold-dependent batch normalization</h3><ul>
<li><p>ANN-to-SNN的方法能使用ANN中所有的训练trick，包括知名的batch normalization，但是模型在ANN-to-SNN映射时会有映射损失。基于梯度近似的BP算法（此文中为STBP）能够直接在SNN上训练，避免先训练后转换的损失，但是由于SNN结构不同，无法直接应用ANN的BN。所以这篇文章提出了适用于直接训练SNN的BN方法tdBN。</p>
</li>
<li><p>公式：</p>
<script type="math/tex; mode=display">
\begin{align}
\hat{x}_k &=\frac{\alpha V_{th}(x_k-E[x_k])}{\sqrt{Var[x_k]+\epsilon}}\\
y_k&=\lambda_k\hat{x}_k+\beta_k
\end{align}</script><p>其中 $\alpha$ 是超参，$V_{th}$ 是阈值电压，其他的参数和ANN的BN意义相同，即做channel-wise的统计并取得统计量用于inference的计算，训练时则使用minibatch 的统计量， 不同的是求均值/方差的时候还要在SNN新增的时间维度上求，即对(N,H,W,T)的张量求均值等。</p>
</li>
</ul>
<p><img src="https://s3.ax1x.com/2020/11/22/D85wx1.png" alt="image-20201122170903068"></p>
<ul>
<li><p>理论解释：</p>
<ul>
<li>关于防止梯度消失/爆炸的作用：有点长，先码着。涉及到另一篇分析grad norm的文章，理论性比较强。</li>
<li>关于公式里多出来的scaling factor：总体是为了平衡firing rate设计的，理论细节先鸽了。</li>
</ul>
</li>
</ul>
<h3 id="Deep-Spiking-Residual-Network"><a href="#Deep-Spiking-Residual-Network" class="headerlink" title="Deep Spiking Residual Network"></a>Deep Spiking Residual Network</h3><ul>
<li>结构总体和ANN相同：ReLU替换为LIF（激活），BN替换为tdBN。区别主要是<ul>
<li>在shortcut的连接上也加了tdBN。</li>
<li>与最后的add操作相连的tdBN中，$\alpha=1/\sqrt{2}$ 。</li>
</ul>
</li>
<li>因为tdBN的目的是平衡firing rate，所以要将fire单元前的所有输入都norm一遍。α的取值能保证相加后特征图方差符合要求。</li>
</ul>
<p><img src="https://s3.ax1x.com/2020/11/22/D8IneK.png" alt="image-20201122170903063"></p>
<h3 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h3><ul>
<li>CIFAR10上的结果很漂亮。由于加入了BN，（从表上看）训练出来的ResNet19对其他结果都是降维打击。在timesteps=6的情况下就能达到SOTA（一般timesteps调高能很暴力地涨点）。不过表中用作baseline的ANN结构ResNet19只有90.6%的ACC，我记着这网络起码也能有93%左右的，不知道这个数据是什么意思。</li>
<li>跑了ImageNet，文章声称它是第一个直接训练SNN算法跑ImageNet的。结果也不错，而且timesteps也只有6，相比其他动辄几百上千的timesteps确实低很多（有一个用VGG跑了2500steps的，还好是ANN2SNN的方法）。</li>
<li>脉冲数据集上测了DVS-Gesture和他们自录的DVS-CIFAR10。对于DVS-Gesture，超参设置是dt=30ms，T=40 steps。结果平均比之前的SOTA高了1到2个点，有点夸张。</li>
<li>DVS-CIFAR10的结果也是SOTA。</li>
</ul>
<p><img src="https://s3.ax1x.com/2020/11/22/D8IudO.png" alt="result"></p>
]]></content>
      <categories>
        <category>论文</category>
        <category>SNN</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>SNN</tag>
      </tags>
  </entry>
  <entry>
    <title>Spatio-Temporal Backpropagation for Training High-Performance Spiking Neural Networks</title>
    <url>/2020/12/15/%E7%AC%94%E8%AE%B0-STBP/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><a href="https://www.frontiersin.org/articles/10.3389/fnins.2018.00331/full">Spatio-temporal backpropagation for training high-performance spiking neural networks - 原文</a> ；本文刊登在2018年 Frontiers in Neuroscience 期刊上。</li>
<li>BPTT-inspired的方法，文章的主要思想是以迭代式的方式近似LIF模型，使得LIF模型网络的推理过程变为线性迭代（线性地完成时域和空间域的迭代，是谓”spatio-temporal”），从而可以根据迭代式进行反向传播。对于脉冲激活函数的梯度，文章设计了数种不同的梯度近似函数，取得了不错的效果。</li>
</ul>
<a id="more"></a>
<h3 id="LIF-Model"><a href="#LIF-Model" class="headerlink" title="LIF Model"></a>LIF Model</h3><ul>
<li><p>LIF（Leaky Integrate and Fire）模型即带leaky漏电、integrate对脉冲积分、fire发放脉冲等主要特征的神经元模型。其微分方程为：</p>
<script type="math/tex; mode=display">
\tau \frac{du(t)}{dt}=-u(t)+I(t)\tag{1}</script><ul>
<li>其中 $u$ 代表膜电势，$I$ 代表电流，$\tau$ 为一个漏电常量。</li>
</ul>
</li>
<li><p>微分方程在数值上求解需要转为迭代式：</p>
</li>
</ul>
<script type="math/tex; mode=display">
u(t)=u(t_{i-1})e^{\frac{t_{i-1}-t}{\tau}}+\hat{I}(t)\tag{2}</script><h3 id="STBP-Method"><a href="#STBP-Method" class="headerlink" title="STBP Method"></a>STBP Method</h3><ul>
<li><p>本文更具体地将LIF模型对应到SNN模型，迭代式可以转化为三步：</p>
<script type="math/tex; mode=display">
\begin{align}
x^{t+1,n}_i&=\sum^{l(n-1)}_{j=1}w^n_{ij}o^{t+1,n-1}_j\tag{3}\\
u^{t+1,n}_i&=u^{t,n}_if(o^{t,n}_i)+x^{t+1,n}_i+b^n_i\tag{4}\\
o^{t+1,n}_i&=g(u^{t+1,n}_i)\tag{5}
\end{align}</script><p>其中</p>
<script type="math/tex; mode=display">
\begin{align}
f(x)&=\tau e^{-\frac{x}{\tau}}\tag{6}\\
g(x)&=1 \text{  if  }x\geq V_{th} \text{ else }0\tag{7}
\end{align}</script><p>$x$ 为神经元的输入，$u$ 为神经元电势，$o$ 为神经元的输出。式(3)的含义是：神经元的输入为前层神经元输出的加权和；式(4)的含义是：当前时刻电势=前一时刻电势×漏电/发放函数+神经元输入+偏置；式(5)的含义是，若电势大于阈值，则发放脉冲。</p>
</li>
<li><p>本文提出式(6)的近似式：</p>
<script type="math/tex; mode=display">
\begin{align}
f(o^{t,n}_i)\approx\left\{
    \begin{array} 
        s\tau, o^{t,n}_i=0 \\
        0, o^{t,n}_i=1
    \end{array}
    \right. \tag{8}
\end{align}</script></li>
<li><p>本文提出 $g$ 的一个梯度近似：</p>
<script type="math/tex; mode=display">
h(u)=\frac{1}{a_1}sign(|u-V_{th}|<\frac{a_1}{2})\tag{9}</script></li>
<li><p>至此，在SNN上使用BP的障碍已经全部被扫清。前推中核心的(3)(4)(5)式全部可导。</p>
<ul>
<li><p>前推顺序为：1）对于每一个时间t，计算完一次完整的前推过程并更新电势；2） 计算下一个时间t。</p>
</li>
<li><p>每层的权重都有t个状态；由于前推过程中每一层的输出结果都依赖于 1）相同t前一层的输出 ；2）前一个t同一层的电势。所以前推的依赖关系在所有的权重状态中可以构成一个有向无环图，可以直接根据前推路径进行反向传播。</p>
<p><img src="https://s1.ax1x.com/2020/10/05/0YgEHs.png" alt="image 20201005164809424"></p>
</li>
</ul>
</li>
</ul>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p>论文中其余篇幅主要是参数选择、g的梯度近似的选择、反向传播公式推导以及实验结果。在此略去不表。</p>
]]></content>
      <categories>
        <category>论文</category>
        <category>SNN</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>SNN</tag>
      </tags>
  </entry>
  <entry>
    <title>1. 凸集(1)</title>
    <url>/2019/02/26/%E7%AC%94%E8%AE%B0-%E5%87%B8%E4%BC%98%E5%8C%961/</url>
    <content><![CDATA[<h2 id="Convex-Set-1"><a href="#Convex-Set-1" class="headerlink" title="Convex Set(1)"></a>Convex Set(1)</h2><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><ul>
<li>主要说明了一些学习前需要了解的重要概念和前置知识。</li>
<li><a href="https://web.stanford.edu/~boyd/cvxbook/">boyd教授的凸优化主页</a></li>
<li><a href="http://www.math.ucla.edu/~wotaoyin/math273a/">ucla的凸优化课程主页</a></li>
<li><a href="http://bicmr.pku.edu.cn/~wenzw/opt-2018-fall.html">pku的凸优化课程主页</a></li>
</ul>
<a id="more"></a>
<h2 id="1-Line-and-segments"><a href="#1-Line-and-segments" class="headerlink" title="1. Line and segments"></a>1. Line and segments</h2><ul>
<li>$y: \theta x_1+(1-\theta)x_2, \theta\in \textrm{R}$</li>
</ul>
<h2 id="2-Affine-sets-仿射集"><a href="#2-Affine-sets-仿射集" class="headerlink" title="2. Affine sets(仿射集)"></a>2. Affine sets(仿射集)</h2><ul>
<li>$\mathcal{C}\subseteq \textrm{R}^n $ is affine <ul>
<li>if $\forall x_1,x_2\in \mathcal{C}$ , then ${\theta x_1+(1-\theta)x_2\mid \theta\in \textrm{R}}\subseteq \mathcal{C}$</li>
<li>if $\forall x_1,x_2,\cdots,x_k$ , then ${\theta_1 x_1+\cdots \theta_k x_k \mid \sum\theta_i=1}\subseteq \mathcal{C}$</li>
<li>if $\mathcal{V}=C-x_0={x-x_0 \mid x\in \mathcal{C}}$ is a subspace, if $x_0\in \mathcal{C}$</li>
<li>affine hall</li>
</ul>
</li>
</ul>
<h2 id="3-Convex-set"><a href="#3-Convex-set" class="headerlink" title="3. Convex set"></a>3. Convex set</h2><ul>
<li>$\mathcal{C}$ is convex if $x_1, x_2 \in \mathcal{C}, 0\leq\theta\leq 1, \theta x_1+(1-\theta)x_2 \in \mathcal{C}$<ul>
<li>smaller than affine sets cause for every 2 points it’s a segment but not a line in convex set </li>
</ul>
</li>
</ul>
<h2 id="4-Convex-cone"><a href="#4-Convex-cone" class="headerlink" title="4. Convex cone"></a>4. Convex cone</h2><ul>
<li>$\mathcal{C}$ is cone if $x\in \mathcal{C}, {\theta x\mid \theta\geq 0}\subseteq \mathcal{C}$</li>
<li>$\mathcal{C}$ is convex cone if $x_1, x_2\in \mathcal{C}, {\theta x_1+\theta x_2\mid\theta_1,\theta_2\geq 0}\subseteq \mathcal{C}$<ul>
<li>$\alpha\theta_1 x_1+(1-\theta_1)x_2$ </li>
</ul>
</li>
</ul>
<blockquote>
<p>Eg.</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Line</th>
<th>segment</th>
<th>affinesets</th>
</tr>
</thead>
<tbody>
<tr>
<td>Convexity</td>
<td>T</td>
<td>T</td>
<td>T</td>
</tr>
<tr>
<td>Convex cone</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
</tbody>
</table>
</div>
<h2 id="5-Other-eg"><a href="#5-Other-eg" class="headerlink" title="5. Other eg"></a>5. Other eg</h2><h3 id="5-1-Hyperplanes"><a href="#5-1-Hyperplanes" class="headerlink" title="5.1 Hyperplanes"></a>5.1 Hyperplanes</h3><ul>
<li>${x\mid a^Tx=b}={x\mid a^Tx=a^Tx_0}={x\mid a^T(x-x_0)=0}$<br>so $a$ is normal direction<br>$={x_0+v\mid a^Tv=0}=x_0+a^\perp(a^\perp={v\mid a^Tv=0})$</li>
<li>Halfspaces ${x\mid a^Tx\leq b}$</li>
</ul>
<h3 id="5-2-Euclidean-balls-and-ellipsoids"><a href="#5-2-Euclidean-balls-and-ellipsoids" class="headerlink" title="5.2 Euclidean balls and ellipsoids"></a>5.2 Euclidean balls and ellipsoids</h3><ul>
<li>$B(x,r)={y\mid |x-y|_2\leq r}={x+ru\mid|u|_2\leq 1}$</li>
<li>$E={x\mid(x-x_c)^TP^{-1}(x-x_c)\leq 1}, P&gt;0$ that is using $P$ to scale ball</li>
</ul>
<h3 id="5-3-Norm-balls-and-cones"><a href="#5-3-Norm-balls-and-cones" class="headerlink" title="5.3 Norm balls and cones"></a>5.3 Norm balls and cones</h3><ul>
<li>Norm Cone:<br> $\mathcal{C}={(x,t)\mid |x|\leq t}\subseteq \textrm{R}^{n+1}$</li>
<li>Transfer n dimension function into n+1 dimension set(x+f(x))</li>
</ul>
<h3 id="5-4-Pohedra"><a href="#5-4-Pohedra" class="headerlink" title="5.4 Pohedra"></a>5.4 Pohedra</h3><ul>
<li>Polyhedron: $P={x\mid Ax\leq b, Cx=d}$<ul>
<li>Hyperplanes + Halfspaces</li>
</ul>
</li>
<li>Simplex: <script type="math/tex">\mathcal{C}=conv\{v_0,\cdots,v_k\}=\{x=\theta_0v_0+\theta_1v_1+\cdots+\theta_kv_k\mid\theta_i\geq 0,\forall i, \sum\theta_i=1\}</script><br>$={x_0+By\mid y\geq0,\sum y_i\leq 1}, B=(v_1-v_0, \cdots,v_k-v_0)$<br>$\exists$ non-singular $A\in R^{n×n}$ such that<script type="math/tex; mode=display">AB=\begin{pmatrix}A_1B\\A_2B \end{pmatrix}\begin{pmatrix}I\\0 \end{pmatrix}</script>$\mathcal{C}={x\mid A_2v_0=A_2x, A_1x\geq A_1v_0, 1^TA_1x\leq 1+1^TA_1v_0}$</li>
</ul>
<h3 id="5-5-positive-semi-definite-cone"><a href="#5-5-positive-semi-definite-cone" class="headerlink" title="5.5 positive semi-definite cone"></a>5.5 positive semi-definite cone</h3><script type="math/tex; mode=display">
\begin{align}
S^n&=\{x\in \textrm{R}^{n×n}\mid x=x^T\}\\
S^n_+&=\{x\in \textrm{S}^n\mid x\geq 0\}\\
S^n_{++}&=\{x\in \textrm{S}^n\mid x>0\}\\
\end{align}</script>]]></content>
      <categories>
        <category>笔记</category>
        <category>凸优化</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>凸优化</tag>
      </tags>
  </entry>
  <entry>
    <title>2. 凸集(2)</title>
    <url>/2019/03/01/%E7%AC%94%E8%AE%B0-%E5%87%B8%E4%BC%98%E5%8C%962/</url>
    <content><![CDATA[<h2 id="Convex-Sets-2"><a href="#Convex-Sets-2" class="headerlink" title="Convex Sets(2)"></a>Convex Sets(2)</h2><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><ul>
<li>这一篇笔记涉及的东西比较抽象，且涉及比较多实变中的定义。对度量空间上的各类集合性质不甚熟悉的话，学起来会比较吃力（特别是一些证明）。我认为需要首先掌握好重要的概念，并且对定理有直观的认识体会（先不要求严格证明）。</li>
</ul>
<a id="more"></a>
<ul>
<li>定义复习：<ul>
<li>闭集S：S的所有聚点都在S中</li>
<li>开集S：闭集的补集</li>
<li>可列集：S的基数和自然数集相当</li>
<li>紧集：任一开覆盖都包含有限子覆盖；$R^n$ 中的紧集是有界闭集</li>
</ul>
</li>
</ul>
<h2 id="1-Operations-that-preserve-convexity"><a href="#1-Operations-that-preserve-convexity" class="headerlink" title="1. Operations that preserve convexity"></a>1. Operations that preserve convexity</h2><p>$f: \mathcal{R}^m\rightarrow\mathcal{R}^n$ preserves convexity if $f(S)$ is convex for any $S\subseteq R$</p>
<h3 id="1-1-Intersection"><a href="#1-1-Intersection" class="headerlink" title="1.1 Intersection"></a>1.1 Intersection</h3><ul>
<li>$S_1\cap S_2$ convex, if $S_1, S_2$ convex</li>
</ul>
<h3 id="1-2-Affine-transform"><a href="#1-2-Affine-transform" class="headerlink" title="1.2 Affine transform"></a>1.2 Affine transform</h3><ul>
<li>$f(x)=Ax+b: \mathcal{R}^n\rightarrow\mathcal{R}^m ,(A\in R^{m\times n})$</li>
<li>$f(S)$ convex if $S$ is convex<br>$f^{-1}(S)={x\mid Ax+b\in S}$ is convex</li>
<li>Eg. $S_1\times S_2 ={(u,v)\mid u\in S_1, v\in S_2}$<br>$S_1+S_2={u+v\mid u\in S_1, v\in S_2}$<br>$f(u,v)=u+v$</li>
</ul>
<h3 id="1-3-Perspective-function"><a href="#1-3-Perspective-function" class="headerlink" title="1.3 Perspective function"></a>1.3 Perspective function</h3><ul>
<li>perspective transform:<br>$P:R^{n+1}\rightarrow R^n$<br>and $(x,t)\rightarrow \frac{x}{t}$<br>with $dom(P)={(x,t)\mid x\in R^n, t&gt;0}$<br>If $S\subseteq dom(P)$ and convex $\rightarrow P(S)$ is convex<blockquote>
<p>Proof:<br>$\forall P(x),P*y( x,y\in S,$ we need to prove $[P(x), P(y)]\subseteq P(S)$ …<br>Just calculate..(</p>
</blockquote>
</li>
<li>$P^{-1}:R^n \rightarrow R^{n+1}$<br>$P^{-1}(C)={(x,t)\mid \frac{x}{t}\in C, t&gt;0 }$<br>If $C$ is convex, then $P^{-1}(C) convex$</li>
</ul>
<h3 id="1-4-Linear-fractional"><a href="#1-4-Linear-fractional" class="headerlink" title="1.4 Linear fractional"></a>1.4 Linear fractional</h3><script type="math/tex; mode=display">f(x)=\frac{Ax+b}{c^Tx+d}$$ for $c^Tx+d>0$
- $f(x)=p_0g$
$$g(x)=\begin{pmatrix}A\\c^T\end{pmatrix}x+\begin{pmatrix}b\\d\end{pmatrix}, p(x,t)=\frac{x}{t}, t>0</script><p>If $S$ is convex $\rightarrow f(s)=p_0g(S)$ convex</p>
<blockquote>
<p>(Operation 不一定是严格的映射)</p>
</blockquote>
<h2 id="2-Separation-theorem"><a href="#2-Separation-theorem" class="headerlink" title="2. Separation theorem"></a>2. Separation theorem</h2><p>If  $C,D$ are two non-empty, disjoint, convex sets, then </p>
<script type="math/tex; mode=display">\exists a\neq 0, a\in R^n, b\in R, s.t.\\
1.a^Tx\leq b,\forall x\in C\\
2.a^Tx\geq b,\forall x\in D</script><blockquote>
<p>算是一个符合直觉的结论，两个非空凸集不相交的话一定会有一个超平面将两个凸集隔开<br>但是证明并不好证<br>逆命题需要加条件，需要其中一个集合为开 </p>
<p>Proof<br>通过构造两个凸集之间的”平分线（超平面）“来找到相应的a和b，然后计算a和b满足条件<br>其中需要考虑多种情况(开集/闭包包含0)</p>
</blockquote>
<h2 id="3-Strict-Separation"><a href="#3-Strict-Separation" class="headerlink" title="3. Strict Separation"></a>3. Strict Separation</h2><p>If  $C,D$ are two non-empty, disjoint, convex sets, then strict separation is</p>
<script type="math/tex; mode=display">\exists a\neq 0, a\in R^n, b\in R, s.t.\\
1.a^Tx< b,\forall x\in C\\
2.a^Tx> b,\forall x\in D</script><p>$C$ is convex closed set, $x_0\neq C \Leftrightarrow$ strict separation<br>$\overline{C-D}\cap{0}=\varnothing \Leftrightarrow$ strict separation</p>
<h2 id="4-Convex-cone"><a href="#4-Convex-cone" class="headerlink" title="4. Convex cone"></a>4. Convex cone</h2><ul>
<li>k is a proper cone if </li>
</ul>
<ol>
<li>convex</li>
<li>closed</li>
<li>solid</li>
<li>pointed</li>
</ol>
<ul>
<li><p>generalized inequalities:</p>
</li>
<li><p>Define partial order:<br>$x\preceq_K y \Leftrightarrow y-x\in K$<br>$x\prec_K y \Leftrightarrow y-x\in int(K)$ 是K的内点</p>
</li>
</ul>
<blockquote>
<p>x和y的偏序关系不一定非得成立其中一个</p>
</blockquote>
<h3 id="4-1-Dual-cone"><a href="#4-1-Dual-cone" class="headerlink" title="4.1 Dual cone"></a>4.1 Dual cone</h3><ul>
<li>Let k be a cone<br>$k^*={y\mid x^Ty\geq 0, \forall x\in k}$</li>
</ul>
<blockquote>
<p>k 可以定义成任意集合，无所谓</p>
</blockquote>
<ul>
<li>Properties:</li>
</ul>
<ol>
<li>$k^*$ is closed, convex cone</li>
<li>$k_1\subseteq k_2\rightarrow k^*_2\subseteq k_1^※$</li>
<li>$k^*=\overline{conv(K)}$</li>
<li>if K is proper cone, K<em> is proper cone and  K*</em>=K</li>
</ol>
<ul>
<li>Some eg</li>
</ul>
<ol>
<li>$K=R^n<em>+\rightarrow  K^*=R^n</em>+$</li>
<li>$K=S^n<em>+\rightarrow K^*=S^n</em>+$</li>
<li>$K={(x,t)\mid |x|\leq t}\rightarrow K^*{(u,v)\mid |u|\leq v}$</li>
</ol>
<h3 id="Minimum-and-minimal-element-of-S"><a href="#Minimum-and-minimal-element-of-S" class="headerlink" title="Minimum and minimal element of S"></a>Minimum and minimal element of S</h3><ul>
<li>x is a minimum element of S $\Leftrightarrow S\subset x+K$ 最小元</li>
<li>x is a minimal element of S $\Leftrightarrow (x-K)\cap S={x}$ 极小元</li>
</ul>
<blockquote>
<p>最小元条件更强，且要么不存在要么为1(?)</p>
</blockquote>
<ul>
<li><ul>
<li>x is a minimum element of S $\Leftrightarrow \forall \lambda \succ_{K^*}0, x$ is the unique minimizer of $\lambda^T z $ over S</li>
<li>x is a minimal element of S $\Leftarrow$ for some $\lambda\succ_{K^*}0$ , x is the minimizer of $\lambda^Tz$ over S</li>
</ul>
</li>
</ul>
<blockquote>
<p>极小元条件的右方向不成立。直接用极小元定义可以看出来（一个口向左下的C字集合）。如果S凸，那么右方向成立<br>每个集合S可以从原点引一锥包K，可求对偶锥K<em>。若一超平面法向（即 $\lambda$）在K</em>内，则超平面可以作一个极小元(?)</p>
</blockquote>
<p><img src="https://s2.ax1x.com/2019/03/08/kzxMjO.png" alt=""></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>凸优化</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>凸优化</tag>
      </tags>
  </entry>
  <entry>
    <title>3. 凸函数(1)</title>
    <url>/2019/03/08/%E7%AC%94%E8%AE%B0-%E5%87%B8%E4%BC%98%E5%8C%963/</url>
    <content><![CDATA[<h2 id="Convex-functions-1"><a href="#Convex-functions-1" class="headerlink" title="Convex functions(1)"></a>Convex functions(1)</h2><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><ul>
<li>主要介绍了凸函数及其性质</li>
</ul>
<a id="more"></a>
<h2 id="1-Definition"><a href="#1-Definition" class="headerlink" title="1. Definition"></a>1. Definition</h2><ul>
<li>$f:\mathcal{R^n}\rightarrow \mathcal{R}$ is convex if $\textbf{dom}\ f$ is convex set and<script type="math/tex; mode=display">f[\theta x+(1-\theta)y]\leq \theta f(x)+(1-\theta)f(y)</script>for all $x, y\in\textbf{dom}\ f, 0\leq\theta\leq 1$</li>
</ul>
<h2 id="2-Convex-Examples"><a href="#2-Convex-Examples" class="headerlink" title="2.  Convex Examples"></a>2.  Convex Examples</h2><ul>
<li>on $\mathcal{R}$<ul>
<li>affine</li>
<li>exponential</li>
<li>powers</li>
<li>powers of absolute value</li>
<li>negative entropy</li>
</ul>
</li>
<li>on $\mathcal{R}^n$<ul>
<li>affine</li>
<li>norms</li>
</ul>
</li>
<li>on $\mathcal{R}^{m\times n}$<ul>
<li>affine</li>
<li>spectral norm</li>
</ul>
</li>
</ul>
<h2 id="3-Restriction-of-a-convex-function-to-a-line"><a href="#3-Restriction-of-a-convex-function-to-a-line" class="headerlink" title="3. Restriction of a convex function to a line"></a>3. Restriction of a convex function to a line</h2><p>$f:R^n\rightarrow R$ is convex if and only if the function $g:R\rightarrow R$</p>
<script type="math/tex; mode=display">g(t)=f(x+tv), \textbf{dom}\ g=\{t\mid x+tv\in \textbf{dom}\ f\}</script><p>is convex for any $x\in\textbf{dom}\ f, v\in \mathcal{R}^n$</p>
<blockquote>
<p>把 $f$ 定义域限定在任意空间直线上是凸的，那么 $f$ 是凸的。注意 $x+tv$ 中 $x,v\in\mathcal{R^n}$ 只有 $t\in\mathcal{R}$ ，$x,v$ 可变并控制是哪条直线</p>
</blockquote>
<h2 id="4-Extended-value-extension"><a href="#4-Extended-value-extension" class="headerlink" title="4. Extended-value extension"></a>4. Extended-value extension</h2><p><img src="https://s2.ax1x.com/2019/03/08/kzvT9P.png" alt=""></p>
<h2 id="5-First-order-condition"><a href="#5-First-order-condition" class="headerlink" title="5. First-order condition"></a>5. First-order condition</h2><p><img src="https://s2.ax1x.com/2019/03/08/kzvbjS.png" alt=""></p>
<h2 id="6-Second-order-condition"><a href="#6-Second-order-condition" class="headerlink" title="6. Second-order condition"></a>6. Second-order condition</h2><p><img src="https://s2.ax1x.com/2019/03/08/kzvLng.png" alt=""></p>
<blockquote>
<p>一阶条件和二阶条件，总的来说和一元函数差不多</p>
</blockquote>
<h3 id="Epigraph"><a href="#Epigraph" class="headerlink" title="Epigraph"></a>Epigraph</h3><p><img src="/Users/pingguo/Desktop/凸优化/image/11.png" alt="11"></p>
<h3 id="Jensen’s-inequality"><a href="#Jensen’s-inequality" class="headerlink" title="Jensen’s inequality"></a>Jensen’s inequality</h3><p><img src="/Users/pingguo/Desktop/凸优化/image/12.png" alt="12"></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>凸优化</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>凸优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Comprehensive SNN Compression using ADMM Optimization and Activity Regularization</title>
    <url>/2020/12/15/%E7%AC%94%E8%AE%B0-SNNcompression/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><a href="https://arxiv.org/pdf/1911.00822.pdf">Comprehensive SNN Compression using ADMM Optimization and Activity Regularization - 原文</a> 。</li>
<li>文章把ADMM剪枝和量化用到了SNN当中，并提出了降低firing rate的activity regularization方法。</li>
</ul>
<a id="more"></a>
<h3 id="Compression"><a href="#Compression" class="headerlink" title="Compression"></a>Compression</h3><ul>
<li>整体思路基本参照：<a href="https://arxiv.org/pdf/1812.11677.pdf">ADMM-NN: An Algorithm-Hardware Co-Design Framework of DNNs Using Alternating Direction Method of Multipliers</a> ，ASPLOS 19（体系结构顶会）。</li>
</ul>
<h4 id="Pruning"><a href="#Pruning" class="headerlink" title="Pruning"></a>Pruning</h4><ul>
<li><p>admm-pruning在ANN上的论文：<a href="https://arxiv.org/pdf/1804.03294.pdf">A Systematic DNN Weight Pruning Framework using Alternating Direction Method of Multipliers</a> ，ECCV 18。</p>
</li>
<li><p>方法和上文大同小异。由于我们可以使用STBP把SNN训练问题当做普通ANN优化问题来做，所以ADMM结合STBP的使用和在ANN上使用并无不同。</p>
</li>
</ul>
<h4 id="Quantization"><a href="#Quantization" class="headerlink" title="Quantization"></a>Quantization</h4><ul>
<li>同理，参考冷聪18年AAAI的<a href="https://thiswinex.github.io/2019/02/12/%E8%AE%BA%E6%96%87-Low-bit-quantization/">ADMM量化论文</a>。方法基本相同。</li>
</ul>
<h4 id="Activity-regularization"><a href="#Activity-regularization" class="headerlink" title="Activity regularization"></a>Activity regularization</h4><ul>
<li>简单地把loss项加入正则项 $\lambda R$ ，其中R是每个神经元、每步的平均firing rate。</li>
<li>之前有类似的正则化项方法被提出过，但是没有结合STBP，即使用的ANN2SNN方法。</li>
</ul>
<hr>
<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><ul>
<li>实验结果我没有分析。现在的SNN效果也比不上ANN，这样看几个点的涨跌也说明不了什么。</li>
</ul>
]]></content>
      <categories>
        <category>论文</category>
        <category>SNN</category>
      </categories>
      <tags>
        <tag>论文</tag>
        <tag>SNN</tag>
        <tag>NN压缩与加速</tag>
      </tags>
  </entry>
  <entry>
    <title>Spiking-YOLO:Spiking Neural Network for Energy-Efficient Object Detection</title>
    <url>/2020/12/15/%E7%AC%94%E8%AE%B0-SNNyolo/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><a href="https://arxiv.org/pdf/1903.06530.pdf">Spiking-YOLO:Spiking Neural Network for Energy-Efﬁcient Object Detection - 原文</a> ；AAAI 20。</li>
<li>IF模型，SNN在检测领域的一次尝试</li>
<li>新的norm方法</li>
<li>imbalanced threshold</li>
</ul>
<a id="more"></a>
<h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h3><ul>
<li><p>ANN-to-SNN方法</p>
</li>
<li><p>IF模型（似乎没有明说，但在relate work里提到）</p>
</li>
</ul>
<h3 id="Key-Point"><a href="#Key-Point" class="headerlink" title="Key Point"></a>Key Point</h3><ul>
<li>新的channel wise的norm方法（就是把常用的layer-wise的方法改了一下）。看实验数据的话，对平衡firing rate效果不错。</li>
</ul>
<p><img src="https://s3.ax1x.com/2020/11/23/DJwMT0.png" alt="image-20201123142221085"></p>
<ul>
<li>imbalanced threshold 模拟 leaky relu<ul>
<li>新的负阈值（与正阈值不对称，<script type="math/tex">V_{th-}=-V_{th+}/\alpha</script>，模拟leaky的α）</li>
<li>超过负阈值发放负脉冲（模拟leaky relu的负值激活）</li>
</ul>
</li>
</ul>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p>然后论文跑了一下实验，其他部分就没啥了，图我也不放了。文章更大的亮点可能还是做了个性能还行的SNN版本yolo，而且还没有上板测试，是纯理论的模型。<del>把以上几点搅拌到一起，一篇AAAI就诞生了</del>。</p>
<p>另一个需要注意的点是<strong>SNN要如何处理回归问题</strong>。YOLO里需要对bounding box进行回归，这对离散的SNN来说是一个非常难处理的问题。因为回归问题要求高精确度的浮点值（而非相对的分类结果），天然与SNN的离散性相悖。所以，基于bounding box回归的方法肯定不是SNN做检测的最优解，Spiking YOLO花费上千的timesteps来做一帧的检测也实属无奈之举。</p>
]]></content>
      <categories>
        <category>论文</category>
        <category>SNN</category>
      </categories>
      <tags>
        <tag>目标检测</tag>
        <tag>论文</tag>
        <tag>SNN</tag>
      </tags>
  </entry>
  <entry>
    <title>4. 凸优化问题(1)</title>
    <url>/2019/04/24/%E7%AC%94%E8%AE%B0-%E5%87%B8%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98-1/</url>
    <content><![CDATA[<h2 id="Convex-Optimization-Problems-1"><a href="#Convex-Optimization-Problems-1" class="headerlink" title="Convex-Optimization Problems(1)"></a>Convex-Optimization Problems(1)</h2><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><ul>
<li>介绍了一些经典的优化问题，不止于凸优化问题</li>
<li>仍然有很多问题（几何规划、向量规划、广义不等式约束等等）以及关于SDP和SOCP的一些拓展未在此处给出，未来用到的时候再继续写点。</li>
</ul>
<a id="more"></a>
<h2 id="1-Convex-optimization-problems"><a href="#1-Convex-optimization-problems" class="headerlink" title="1. Convex optimization problems"></a>1. Convex optimization problems</h2><ul>
<li><p>Standard form:</p>
<p>minimize $f_0(x)$</p>
<p>subject to $f_i(x)\leq 0, i=1,\cdots,m, a^T_ix=b_i,i=1,\cdots,p$</p>
<p>Note: $f_0$ is convex, $f_1,\cdots,f_n$ are convex, $a^T_ix=b_i$ are affine.</p>
</li>
</ul>
<blockquote>
<p>可以注意到凸优化问题的可行集为凸</p>
</blockquote>
<ul>
<li><p><strong>Any local optimal point is globally optimal</strong></p>
</li>
<li><p>Optimality criterion for differentiable $f_0$ </p>
<p>$x$ is optimal <strong>iff</strong> it’s feasible $(x\in X)$ and $\triangledown f_0(x)^T(y-x)\geq 0$ </p>
</li>
</ul>
<blockquote>
<p>$-\triangledown f(x)$ 定义了一个支撑超平面切于 最优点</p>
</blockquote>
<ul>
<li>Equivalent convex problem</li>
</ul>
<blockquote>
<p>包括消除、引入等式约束；加入松弛变量；极小化部分变量；化为上境图问题</p>
</blockquote>
<h2 id="2-Quasiconvex-optimization"><a href="#2-Quasiconvex-optimization" class="headerlink" title="2. Quasiconvex optimization"></a>2. Quasiconvex optimization</h2><ul>
<li><p>Different point: </p>
<p>$x$ is optimal <strong>if</strong> it’s feasible and $\triangledown f_0(x)^T(y-x)&gt;0$</p>
</li>
</ul>
<blockquote>
<p>拟凸问题可以通过构造凸可行性问题来求解</p>
</blockquote>
<h2 id="3-Linear-program"><a href="#3-Linear-program" class="headerlink" title="3. Linear program"></a>3. Linear program</h2><ul>
<li><p>minimize $c^Tx+d$</p>
<p>subject to $Gx\preceq h, Ax=b$</p>
</li>
</ul>
<blockquote>
<p>线性目标函数对凸优化是普适的。</p>
<p>与线性分式问题等价</p>
<p>$\min |x|_1$ s.t. $Ax=b$ 是线性规划问题：<br>$\min t$ s.t. $|x|_1\leq t, Ax=b$ 1范数可以分解成各分量的线性不等式</p>
</blockquote>
<h2 id="4-Quadradic-program"><a href="#4-Quadradic-program" class="headerlink" title="4. Quadradic program"></a>4. Quadradic program</h2><ul>
<li><p>minimize $(1/2)x^TPx+q^Tx+r$</p>
<p>subject to $Gx\preceq h, Ax=b, P\in \textbf{S}^n_+$ </p>
</li>
<li><p>least-squares: minimize $|Ax-b|^2_2$</p>
<p>analytical solution $x^\star = A^\dagger b$</p>
</li>
</ul>
<blockquote>
<p>$A^\dagger$ 是伪逆矩阵的意思， $A=U\Sigma V^T, A^\dagger=V\Sigma^+U^T$</p>
</blockquote>
<h2 id="5-Second-order-cone-programming"><a href="#5-Second-order-cone-programming" class="headerlink" title="5. Second-order cone programming"></a>5. Second-order cone programming</h2><ul>
<li><p>minimize $f^Tx$</p>
<p>subject to $|A_ix+b_i|_2\leq c^T_ix, i=1,\cdots,m, Fx=g$</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>凸优化</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>凸优化</tag>
      </tags>
  </entry>
  <entry>
    <title>4. 凸函数(2)</title>
    <url>/2019/04/24/%E7%AC%94%E8%AE%B0-%E5%87%B8%E5%87%BD%E6%95%B0-2/</url>
    <content><![CDATA[<h2 id="Convex-Function-2"><a href="#Convex-Function-2" class="headerlink" title="Convex Function(2)"></a>Convex Function(2)</h2><h2 id="1-Operation-that-preserve-convexity"><a href="#1-Operation-that-preserve-convexity" class="headerlink" title="1. Operation that preserve convexity"></a>1. Operation that preserve convexity</h2><ol>
<li><p>Positive weighted sum</p>
<p>if $f_1,f_2,\cdots,f_n$ are convex, $\omega_1,\omega_2,\cdots,\omega_n\geq0$, then $f=\sum\omega_if_i$ is convex</p>
</li>
</ol>
<a id="more"></a>
<blockquote>
<p>非负加权求和，仿射变换的扩展</p>
</blockquote>
<ol>
<li><p>Composition with affine function</p>
<p>if $f$ is convex, then $g(x)=f(ax+b)$ is convex</p>
</li>
</ol>
<blockquote>
<p>凸函数复合仿射函数是凸函数</p>
</blockquote>
<ol>
<li><p>Pointwise maximum</p>
<p>if $f_1,f_2$ are convex, then $f(x)=\max{f_1,f_2}$ is convex</p>
</li>
</ol>
<blockquote>
<p>逐点最大操作保凸；<br>可以推广到无穷多个凸集（因为是(定义域)取交？）</p>
</blockquote>
<ol>
<li><p>Pointwise supremum</p>
<p>if $f(x,y)$ is convex, then $g(x)=\sup f(x,y)$ is convex</p>
</li>
</ol>
<blockquote>
<p> 逐点上确界操作保凸</p>
</blockquote>
<ol>
<li><p>Estabilishing by affine function</p>
<p>$f(x)=\sup{g(x)}$ , $g$ is affine</p>
</li>
</ol>
<blockquote>
<p>由凸函数-&gt;仿射函数族的证明：做 $\textbf{epi}\ f$ 上的支撑超平面<br>仿射函数族-&gt;凸函数的证明：多个函数的逐点上确界保凸</p>
<p>保证了共轭函数是凸函数</p>
</blockquote>
<ol>
<li><p>Composition with scalar functions</p>
<p><img src="https://imgchr.com/i/EVbLqS" alt="image-20190329103202902"></p>
</li>
</ol>
<blockquote>
<p>标量函数复合：需满足的条件</p>
</blockquote>
<ol>
<li>Vector composition</li>
</ol>
<p><img src="https://imgchr.com/i/EVbjaQ" alt="image-20190329103401790"></p>
<blockquote>
<p>矢量复合需满足的条件</p>
</blockquote>
<ol>
<li><p>Minimization</p>
<p>if $f(x,y)$ is convex function and $\mathcal{C}$ is a convex set, then $g(x)=\underset{y\in\mathcal{C}}\inf f(x,y)$ is convex</p>
</li>
</ol>
<blockquote>
<p>$g$ 相当于 $f$ 在某个分量上的投影取 $\min$ (想像从y轴的平行方向看$t=f(x,y)$的投影，再把投影生成的面积取下界得到的仍然是凸函数)</p>
</blockquote>
<ol>
<li>Perspective</li>
</ol>
<blockquote>
<p>透视运算保凸</p>
</blockquote>
<h2 id="The-conjugate-function"><a href="#The-conjugate-function" class="headerlink" title="The conjugate function"></a>The conjugate function</h2><ul>
<li><p>Define: $f^*(y)=\underset{x\in\mathbf{dom} f}{\sup}(y^Tx-f(x))$</p>
<blockquote>
<p>相当于这个仿射函数族遍历所有的斜率(斜率为x)，b取$-f(x)$</p>
<p>对仿射函数族取逐点上确界的操作保证了$f^*(y)$ 的凸性，无论$f(x)$是否凸</p>
</blockquote>
</li>
</ul>
<h2 id="2-Quasiconvex-functions"><a href="#2-Quasiconvex-functions" class="headerlink" title="2. Quasiconvex functions"></a>2. Quasiconvex functions</h2><ul>
<li>Define: $f$ is quasiconvex if $S_\alpha ={x\in\mathbf{dom}f\mid f(x)\leq\alpha }$ are convex for all $\alpha$</li>
</ul>
<blockquote>
<p>即定义域为凸，所有下水平集为凸<br><img src="https://imgchr.com/i/EVbqr8" alt="image-20190329111417466"></p>
</blockquote>
<h3 id="2-1-Properties"><a href="#2-1-Properties" class="headerlink" title="2.1 Properties"></a>2.1 Properties</h3><h4 id="Modified-Jensen-inequality"><a href="#Modified-Jensen-inequality" class="headerlink" title="- Modified Jensen inequality"></a>- Modified Jensen inequality</h4><p>$f$ is quasiconvex $\Leftrightarrow$ $f(\theta x+(1-\theta)y)\leq\max{f(x),f(y}$</p>
<h4 id="In-R"><a href="#In-R" class="headerlink" title="- In R"></a>- In R</h4><p>$f$ is quasiconvex $\Leftrightarrow$ $f$ 在 $c\in\mathbf{dom}f$ 左侧非增右侧非减，且 $f$ 非增非减</p>
<h4 id="First-order-condition"><a href="#First-order-condition" class="headerlink" title="- First-order condition"></a>- First-order condition</h4><p>$f$ is quasiconvex $\Leftrightarrow$[ $f(y)\leq f(x)\rightarrow\triangledown f(x)^T(y-x)\leq 0$]</p>
<blockquote>
<p>梯度与 y-x 连线反向</p>
</blockquote>
<h2 id="3-Log-concave-and-log-convex-functions"><a href="#3-Log-concave-and-log-convex-functions" class="headerlink" title="3. Log-concave and log-convex functions"></a>3. Log-concave and log-convex functions</h2><ul>
<li>Define: $f$ is log-convex if for all $x\in\mathbf{dom}f$ , $f(x)&gt;0$ and $\log f$ is convex</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>凸优化</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>凸优化</tag>
      </tags>
  </entry>
  <entry>
    <title>6. 对偶与对偶问题</title>
    <url>/2019/06/05/%E7%AC%94%E8%AE%B0-%E5%AF%B9%E5%81%B6/</url>
    <content><![CDATA[<h2 id="Duality"><a href="#Duality" class="headerlink" title="Duality"></a>Duality</h2><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><ul>
<li>主要记录了对偶问题和对偶方法。由于强对偶性下对偶问题的解与原问题相等，许多问题在原函数性质不好的情况下可以变换到对偶空间去求解。</li>
<li>Why duality? 降低计算复杂度，数据降维等；更好的性质，更光滑、凸。。</li>
</ul>
<a id="more"></a>
<h2 id="1-Lagrangian"><a href="#1-Lagrangian" class="headerlink" title="1. Lagrangian"></a>1. Lagrangian</h2><ul>
<li><p>Standard form problem:</p>
<p>minimize $f_0(x)$</p>
<p>subject to $f_i(x)\leq 0, i=1,\cdots,m, h_i(x)=0,i=1,\cdots,p$ </p>
</li>
<li><p>Lagrangian:</p>
<script type="math/tex; mode=display">
L(x,\lambda,\nu)=f_0(x)+\sum^m_{i=1}\lambda_if_i(x)+\sum^p_{i=1}\nu_ih_i(x)</script></li>
</ul>
<blockquote>
<p>$\lambda,\nu$ 分别是不等式约束和等式约束的拉格朗日乘子</p>
</blockquote>
<h2 id="2-Lagrangian-Dual"><a href="#2-Lagrangian-Dual" class="headerlink" title="2. Lagrangian Dual"></a>2. Lagrangian Dual</h2><script type="math/tex; mode=display">
g(\lambda,\nu)=\inf_{x\in D}L(x,\lambda,\nu)</script><blockquote>
<p>因为 $\inf$ 的存在，且 $L$ 是关于 $\lambda,\nu$ 的仿射函数，对偶函数一定凸且构成了原问题最优值 $p^\star$ 的下界 $g(\lambda,\nu)\leq p^\star$</p>
</blockquote>
<h2 id="3-Lagrange-dual-and-conjugate-function"><a href="#3-Lagrange-dual-and-conjugate-function" class="headerlink" title="3. Lagrange dual and conjugate function"></a>3. Lagrange dual and conjugate function</h2><ul>
<li><p>minimize $f_0(x)$</p>
<p>subject to $Ax\preceq b, Cx=d$</p>
<script type="math/tex; mode=display">
\begin{align}
g(\lambda,\nu)&=\inf_{x\in\textbf{dom}f_0}(f_0(x)+(A^T\lambda+C^T\nu)^Tx-b^T\lambda-d^T\nu)\\
&=-f_0^*(-A^T\lambda-C^T\nu)-b^T\lambda-d^T\nu
\end{align}</script></li>
</ul>
<h2 id="4-The-dual-problem"><a href="#4-The-dual-problem" class="headerlink" title="4. The dual problem"></a>4. The dual problem</h2><ul>
<li><p>maximize $g(\lambda,\nu)$</p>
<p>subject to $\lambda \succeq 0$ </p>
<p>finds best lower bound of $p^\star$_</p>
</li>
</ul>
<h2 id="5-Weak-and-strong-duality"><a href="#5-Weak-and-strong-duality" class="headerlink" title="5. Weak and strong duality"></a>5. Weak and strong duality</h2><ul>
<li><p>weak duality: $d^\star\leq p^\star$</p>
<p>always holds for convex and nonconvex problems</p>
</li>
<li><p>strong duality: $d^\star=p^\star$</p>
<p>Slater’ constraint qualification:</p>
<script type="math/tex; mode=display">
\exists x\in \textbf{int}D: f_i(x)<0, i=1,\cdots,m</script></li>
</ul>
<blockquote>
<p>Slater条件成立即不等式约束可以取严格小于，强对偶性成立。 Slater条件确保拉格朗日函数存在鞍点(参见拉格朗日对偶的鞍点解释，即 $x^\star,\lambda^\star$ 最优且强对偶性成立，则其为 $L$ 的鞍点)</p>
</blockquote>
<h2 id="6-A-nonconvex-problem-with-strong-duality"><a href="#6-A-nonconvex-problem-with-strong-duality" class="headerlink" title="6. A nonconvex problem with strong duality"></a>6. A nonconvex problem with strong duality</h2><blockquote>
<p>对非凸问题也可能存在强对偶条件</p>
<p>无论 $x$ 的维数($x\in \mathcal{R}^n$ )，其对偶问题总是针对 $\lambda\in \mathcal{R}$ 的一维优化。这是个很好的性质，可以直接使问题降维。</p>
</blockquote>
<h2 id="7-Geometric-interpretation"><a href="#7-Geometric-interpretation" class="headerlink" title="7. Geometric interpretation"></a>7. Geometric interpretation</h2><script type="math/tex; mode=display">
g(\lambda)=\inf_{(u,t)\in G}(t+\lambda u)</script><p>where $G={(f_1(x),f_2(x))\mid x\in D}$</p>
<p><img src="/Users/pingguo/Library/Application Support/typora-user-images/image-20190425154237918.png" alt="image-20190425154237918"></p>
<blockquote>
<p>原问题可行集在左半侧(Slater条件)；超平面 $\lambda u+t=g(\lambda)$ 与 $t$ 的交点永远在 $p^*$ 的下边。此处 $\lambda$ 作为自变量变换超平面的”斜率”，取与G相切之后（inf保证相切）与t轴焦点即为 $g(\lambda)$ 。无论怎么交，最优点（最大的 $g(\lambda)$ ）总在 $p^\star$ 下部。 </p>
<p>(弱对偶条件 $d^<em>&lt;p^</em>$)</p>
</blockquote>
<ul>
<li>Epigraph variation:</li>
</ul>
<blockquote>
<p>令 $A$ 为G的上境图，强对偶性成立当$p^\star$ 处可以作非垂直（于坐标轴u）的支撑超平面。</p>
<p>上图G非凸；如果G凸（即对于凸问题），过 $(0,p^\star)$ 可以作支撑超平面。</p>
<p>此时Slater’s condition: 如果存在 $(\tilde{u},\tilde{t})\in A$ 且 $\tilde{u}&lt;0$ ，$(0,p^\star)$ 点的支撑超平面必然不垂直。</p>
</blockquote>
<h2 id="8-Complementary-slackness"><a href="#8-Complementary-slackness" class="headerlink" title="8. Complementary slackness"></a>8. Complementary slackness</h2><ul>
<li><p>assume strong duality holds, $x^\star$ optimal and $(\lambda^\star,\nu^\star)$ dual optimal</p>
<p>obviously we have:</p>
<script type="math/tex; mode=display">
\begin{align}
f_0(x^\star)=g(\lambda^\star,\nu^\star)&=\inf_x\{f_0(x)+\sum\lambda_i^\star f_i(x)+\sum\nu_i^\star h_i(x)\}\\
&\leq f_0(x^\star)+\sum\lambda_i^\star f_i(x^\star)+\sum\nu_i^\star h_i(x^\star)\\
&\leq f_0(x^\star)
\end{align}</script><ul>
<li>First inequality: $x^\star$ minimize $L(x,\lambda^\star,\nu^\star)$ </li>
<li>$\sum \lambda_i^\star f_i(x^\star)=0$</li>
</ul>
</li>
</ul>
<blockquote>
<p>第二个条件即 complementary slackness 互补松弛性，即最优点处除非第i个约束起作用，否则最优拉格朗日乘子的第i项都为零。</p>
</blockquote>
<h2 id="9-KKT-Condition"><a href="#9-KKT-Condition" class="headerlink" title="9. KKT Condition"></a>9. KKT Condition</h2><ul>
<li>For non-convex problem, if strong duality holds, i.e. $x^\star$ minimize $L(x,\lambda^\star,\nu^\star)$ , so its gradient at $x^\star$:<script type="math/tex; mode=display">
\triangledown f_0(x^\star)+\sum \lambda^\star_i\triangledown f_i(x)+\sum\nu^\star_i\triangledown h_i(x)=0</script>so we have KKT condition:<script type="math/tex; mode=display">
\begin{align}
f_i(x^\star)&\leq 0 \text{     primal constraints}\\
h_i(x^\star)&=0 \\
\lambda^\star_i&\geq 0 \text{     dual constraints}\\
\lambda^\star_if_i(x^\star)&=0\text{     complementary slackness}\\
\triangledown f_0(x^\star)+\sum \lambda^\star_i\triangledown f_i(x)+\sum\nu^\star_i\triangledown h_i(x)&=0 \text{     gradient vanish}
\end{align}</script></li>
</ul>
<blockquote>
<p>KKT条件由强对偶性下的非凸问题导出，即在非凸问题中，原问题和对偶问题的一堆最优解必须满足KKT条件(必要条件) 。</p>
<p>（原问题可行性、对偶问题可行性、互补松弛性、最优性）</p>
<p>若原问题为凸，必要条件变为充要条件，满足KKT条件的点是最优解且对偶间隙为零(强对偶)。对于还未知是否满足强对偶性的凸问题，需要满足 Slater 条件。</p>
</blockquote>
<h2 id="10-Example"><a href="#10-Example" class="headerlink" title="10. Example"></a>10. Example</h2><blockquote>
<p>$\underset{y}{\min} \frac{1}{2}|x-y|^2_2$， $s.t. |x|_1=1$ </p>
</blockquote>
<p>待补充</p>
<h2 id="11-LP-SDP-SOCP-Duality"><a href="#11-LP-SDP-SOCP-Duality" class="headerlink" title="11. LP, SDP, SOCP Duality"></a>11. LP, SDP, SOCP Duality</h2><p>待补充</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>凸优化</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>凸优化</tag>
      </tags>
  </entry>
  <entry>
    <title>7. 梯度方法</title>
    <url>/2019/06/05/%E7%AC%94%E8%AE%B0-%E6%A2%AF%E5%BA%A6%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="Gradient-Method"><a href="#Gradient-Method" class="headerlink" title="Gradient Method"></a>Gradient Method</h2><h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h3><ul>
<li>介绍了经典的一阶方法，梯度下降。</li>
</ul>
<a id="more"></a>
<h3 id="1-Gradient-Method"><a href="#1-Gradient-Method" class="headerlink" title="1. Gradient Method"></a>1. Gradient Method</h3><h4 id="1-1-Definition"><a href="#1-1-Definition" class="headerlink" title="1.1 Definition"></a>1.1 Definition</h4><p>选定初始点 $x<em>0$ 并按 $x</em>{k+1}=x_k-t_k\triangledown f(x_k)$ 的方法迭代。其中 $t_k$ 是通过线搜索方法确定的步长。梯度下降法不需要使用二阶条件，不需要计算 Hessian 阵，所以每次迭代的计算代价不高。但是容易出现收敛过慢，在不可微区域失效等缺点。</p>
<blockquote>
<p>为避免歧义，之后用$ x^{(k)}$ 指代一个序列中的第 k 个元素。</p>
</blockquote>
<h3 id="2-First-order-methods"><a href="#2-First-order-methods" class="headerlink" title="2. First-order methods"></a>2. First-order methods</h3><h4 id="2-1-Lipschitz-continuity-gradient"><a href="#2-1-Lipschitz-continuity-gradient" class="headerlink" title="2.1 Lipschitz continuity gradient"></a>2.1 Lipschitz continuity gradient</h4><ul>
<li><p>Lipschitz continuous<br>$|f(x)-f(y)|\leq L|x-y|, \forall x,y\in\textbf{dom} f$ </p>
</li>
<li><p>Lipschitz continuous gradient (L-smooth)<br>  $|\triangledown f(x)-\triangledown f(y)|\leq L|x-y|, \forall x,y\in\textbf{dom} f$</p>
</li>
</ul>
<blockquote>
<p>$|\cdot|, |\cdot|_*$ ? Norm Choice</p>
</blockquote>
<ul>
<li><p>Quadratic upper bound<br>  Lipschitz continuous gradient $\rightarrow (\triangledown f(x)-\triangledown f(y))^T(x-y)\leq L|x-y|^2 ,\forall x,y\in \textbf{dom}f$<br>  which is equivalent to $f(y)\leq f(x)+\triangledown f(x)^T(y-x)+L/2|y-x|^2, \forall x,y\in\textbf{dom}f$ 给出了一个(对y的函数的)二次函数上界(固定x)</p>
</li>
<li><p>Consequensce of quadratic upper bound</p>
<script type="math/tex; mode=display">
\frac{1}{2L}\|\triangledown f(z)\|^2\leq f(z)-f(x^\star)\leq \frac{L}{2}\|z-x^\star\|^2, \forall z</script><p>​        $x^\star$ 是最优值。右侧不等号由 $x=x^\star$ 的二次函数上界给出，左侧不等号由固定 $x=z$ 对 $y$ 优化最小上界得到。</p>
</li>
<li><p>Co-coercivity of gradient</p>
<script type="math/tex; mode=display">
(\triangledown f(x)-\triangledown f(y))^T(x-y)\geq \frac{1}{L} \|\triangledown f(x)-\triangledown f(y)\|^2, \forall x,y</script></li>
</ul>
<p>​        if $f$ is convex and L-Lipschitz continuous gradient<br>​        Lipschitz continuous gradient = upper bound property = co-coercivity of gradient</p>
<h4 id="2-2-Strong-convexity"><a href="#2-2-Strong-convexity" class="headerlink" title="2.2 Strong convexity"></a>2.2 Strong convexity</h4><ul>
<li>$f$ is strongly convex with $m&gt;0$ if dom $f$ is convex and:<script type="math/tex; mode=display">
f(\theta x+(1-\theta)y)\leq \theta f(x)+(1-\theta)f(y)-\frac{m}{2}\theta(1-\theta)\|x-y\|^2</script></li>
<li>m-strongly convex means:<script type="math/tex; mode=display">
f(y)\geq f(x)+\triangledown f(x)^T(y-x)+\frac{m}{2}\|y-x\|^2, \forall x,y\in \textbf{dom} f</script>​        给出了一个二次函数的下界(同样是固定x，对y的函数)</li>
</ul>
<h3 id="2-3-Analysis-of-gradient-method"><a href="#2-3-Analysis-of-gradient-method" class="headerlink" title="2.3 Analysis of gradient method"></a>2.3 Analysis of gradient method</h3><ul>
<li><p>$x_{k+1}=x_k-t_k\triangledown f(x_k)$<br>假设 $f$ 是凸且可微，且梯度为 $L-smooth$ ，存在最优值 $f(x^\star)$。</p>
</li>
<li><p>For one step:</p>
<script type="math/tex; mode=display">
f(x-t\triangledown f(x)) \leq f(x)-t(1-\frac{Lt}{2})\|\triangledown f(x)\|^2_2</script></li>
</ul>
<p>​        (quadratic upper bound)</p>
<p>​        let $x^+=x-t\triangledown f(x)$ , $0&lt;t&lt;1/L$ ,</p>
<script type="math/tex; mode=display">
\begin{align}
f(x^+)&\leq f(x)-\frac{t}{2}\|\triangledown f(x)\|^2_2,(1)\\
f(x^+)-f^\star&\leq(f(x)-f^\star)-\frac{t}{2}\|\triangledown f(x)\|^2_2\\
f(x^+)-f^\star&\leq\triangledown f(x)^T(x-x^\star)-\frac{t}{2}\|\triangledown f(x)\|^2_2\\
&=\frac{1}{2t}(\|x-x^\star\|^2_2)-\|x-x^\star-t\triangledown f(x)\|^2_2)\\
&=\frac{1}{2t}(\|x-x^\star\|^2_2)-\|x^+-x^\star\|^2_2),(2)
\end{align}</script><p>​        (1) shows that $f(x^+)&lt;f(x)$ </p>
<p>​        (2) shows that $|x^+-x^\star|_2&lt;|x-x^\star|_2$ </p>
<p>​        函数值收敛，x值也收敛</p>
<blockquote>
<p>为什么这两者不是等价的?</p>
<p>这是所谓强收敛(Strong Convergence)和弱收敛(Weak Convergence)的区别，(1)即函数值收敛为弱收敛，(2)即点列收敛为强收敛。考虑极限情况——一个”平底锅”函数，弱收敛算法的函数值能够收敛到锅底，但其点列可能在锅的两头反复横跳。</p>
</blockquote>
<ul>
<li>Constant step size:</li>
</ul>
<p>Number of iterations to reach $f(x_k)-f^\star\leq \epsilon$ is $O(1/\epsilon)$ </p>
<blockquote>
<p>如果函数强凸，此条可加强为  $O(\log(1/\epsilon))$  </p>
</blockquote>
<ul>
<li>Backtracking line search</li>
</ul>
<h4 id="2-4-Limits-on-convergence-rate-of-first-order-methods"><a href="#2-4-Limits-on-convergence-rate-of-first-order-methods" class="headerlink" title="2.4 Limits on convergence rate of first-order methods"></a>2.4 Limits on convergence rate of first-order methods</h4><p>(Nestrov) for $k&lt;(n-1)/2$ , we have this theroem of first-order methods above:</p>
<script type="math/tex; mode=display">
f(x_k)-f^\star\geq \frac{3L\|x-x^\star\|^2_2}{32(k+1)^2}</script><blockquote>
<p>即大体可以分为 $1/k$ 级和 $1/k^2$ 级。梯度方法作为一阶方法在后面的一些改进算法中获得了 $1/k^2$ 的收敛速度。</p>
<p>如何评判收敛速度？以下为一些速度标准以及它们的含义</p>
</blockquote>
<p>Q-linear</p>
<script type="math/tex; mode=display">
\frac{\|x^k-x^*\|}{\|x^{k-1}-x^*\|}<\gamma, \gamma\in(0,1)</script><p>super-linear</p>
<script type="math/tex; mode=display">
\frac{\|x^k-x^*\|}{\|x^{k-1}-x^*\|}\rightarrow 0</script><p>quadratic</p>
<script type="math/tex; mode=display">
\frac{\|x^k-x^*\|}{\|x^{k-1}-x^*\|^2}\leq M</script><p>$\epsilon_k$ is Q-linear</p>
<script type="math/tex; mode=display">
\|x^k-x^*\|<\epsilon_k</script>]]></content>
      <categories>
        <category>凸优化</category>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title>变分不等式</title>
    <url>/2019/02/16/%E7%AC%94%E8%AE%B0-%E5%8F%98%E5%88%86%E4%B8%8D%E7%AD%89%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><ul>
<li>大部分学习资料来自于何炳生教授的 <a href="http://maths.nju.edu.cn/~hebma/">主页</a></li>
<li>已弃坑，待填。</li>
</ul>
<a id="more"></a>
<h2 id="1-变分不等式"><a href="#1-变分不等式" class="headerlink" title="1. 变分不等式"></a>1. 变分不等式</h2><ul>
<li>设 $\Omega$ 为 $R^n$ 中的一个非空闭凸集，$F$ 是 $R^n$ 到 $R^n$ 的一个连续映射（向量函数），单调变分不等式问题就是寻找 $x^*$：<script type="math/tex; mode=display">x^*\in\Omega, F(x^*)^T(x-x^*)\geq 0, \forall x \in\Omega</script>单调是指 $F$ 满足 $(u-v)^T(F(u)-F(v))\geq 0$ 。</li>
</ul>
<h2 id="2-与可微凸优化的关系"><a href="#2-与可微凸优化的关系" class="headerlink" title="2. 与可微凸优化的关系"></a>2. 与可微凸优化的关系</h2><p>设 $f: R^n \rightarrow R$ 为可微凸函数，凸优化问题：</p>
<script type="math/tex; mode=display">\min f(x), x\in \Omega</script><p>则最优点必须有：</p>
<ul>
<li>它属于 $\Omega$</li>
<li>它的邻域内无可行下降方向</li>
</ul>
<p>可求 $f$ 梯度 $\triangledown f(x)$ ，记</p>
<ul>
<li>$Sd(x)={s\in R^n| s^T\triangledown f(x)&lt;0}$ 为点 $x$ 处的可行方向集（ $s$ 为下降向量满足逆梯度）</li>
<li>$Sf(x)={s\in R^n| s=x’-x, x’\in\Omega}$ 为点 $x$ 处的下降方向集（ $s$ 为下降向量满足下降后向量仍在集合内）</li>
</ul>
<p>那么凸优化条件可表述为：</p>
<script type="math/tex; mode=display">x\in\Omega,\ \ and\  \ Sf(x)\cap Sd(x)\neq\varnothing</script><p>其等价数学形式为：</p>
<script type="math/tex; mode=display">x\in\Omega, (x'-x)^T\triangledown f(x)\geq 0, \forall x'\in\Omega</script><p>（暂时弃坑，等系统学习完凸优化后再来补充）</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>凸优化</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>凸优化</tag>
      </tags>
  </entry>
  <entry>
    <title>10. 近似点算子</title>
    <url>/2019/07/22/%E7%AC%94%E8%AE%B0-%E8%BF%91%E4%BC%BC%E7%82%B9%E7%AE%97%E5%AD%90/</url>
    <content><![CDATA[<h2 id="The-proximal-mapping"><a href="#The-proximal-mapping" class="headerlink" title="The proximal mapping"></a>The proximal mapping</h2><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><ul>
<li>介绍了近似点映射以及一些常见的函数的近似点映射的例子。</li>
</ul>
<a id="more"></a>
<h2 id="1-Closed-function"><a href="#1-Closed-function" class="headerlink" title="1. Closed function"></a>1. Closed function</h2><h3 id="1-1-Closed-set"><a href="#1-1-Closed-set" class="headerlink" title="1.1 Closed set"></a>1.1 Closed set</h3><ul>
<li>A set $C$ is closed if it contains its boundary:<script type="math/tex; mode=display">
x^k\in C, x^k\rightarrow \overline{x}\Rightarrow\overline{x}\in C</script></li>
</ul>
<ul>
<li>Notice:<script type="math/tex; mode=display">
C \text{  closed}\Rightarrow A^{-1}C\text{  closed}\\
C \text{  closed}, AC=\{Ax\mid x\in C\}\text{  might be open}</script></li>
</ul>
<h3 id="1-2-Closed-function"><a href="#1-2-Closed-function" class="headerlink" title="1.2 Closed function"></a>1.2 Closed function</h3><ul>
<li>See slides</li>
</ul>
<h2 id="2-Conjugate-function"><a href="#2-Conjugate-function" class="headerlink" title="2. Conjugate function"></a>2. Conjugate function</h2><h3 id="2-1-Recall-and-some-example"><a href="#2-1-Recall-and-some-example" class="headerlink" title="2.1 Recall and some example."></a>2.1 Recall and some example.</h3><ul>
<li>See slides</li>
</ul>
<h2 id="3-Proximal-mapping"><a href="#3-Proximal-mapping" class="headerlink" title="3. Proximal mapping"></a>3. Proximal mapping</h2><ul>
<li><p>Definition: proximal mapping of a closed convex function $f$ is</p>
<script type="math/tex; mode=display">
\text{prox}_f(x)=\arg\min_u(f(u)+\frac{1}{2}\|u-x\|^2_2)</script><blockquote>
<p>加入二次项保证强凸性，使 $\arg\min$ 的值唯一</p>
<p>闭性质保证一定有 $\arg\min$ </p>
<p>将 $x$ 映射到近似点 $u$ (意义？)</p>
</blockquote>
</li>
<li><p>Subgradient characterization</p>
</li>
<li><script type="math/tex; mode=display">
u=\text{prox}_f(x)\Leftrightarrow x-u\in\partial f(u)\tag{10-1}</script><p>Proof:</p>
<script type="math/tex; mode=display">
\begin{align}
&\because0\in\partial f(u)+(u-x)\\
&\therefore x-u\in\partial f(u)

\end{align}</script></li>
<li></li>
</ul>
<script type="math/tex; mode=display">
f(x)=g(x)+a^Tx,\ \ \ \ \text{prox}_f(x)=\text{prox}_g(x-a)</script><script type="math/tex; mode=display">
f(x)=g(x)+\frac{\mu}{2}\|x-a\|^2_2\ \ \ \ \text{prox}_{\theta g}(\theta x+(1-\theta)a)</script><ul>
<li><strong>Moreau decomposition</strong></li>
</ul>
<script type="math/tex; mode=display">
x=\text{prox}_f(x)+\text{prox}_{f^*}(x), \forall x</script><p>​            Follows form:</p>
<script type="math/tex; mode=display">
\begin{align}
u=\text{prox}_f(x)&\Leftrightarrow x-u\in\partial f(u)\text{    (10-1)}\\
&\Leftrightarrow u\in\partial f^*(x-u)\text{    (8-1)}\\
&\Leftrightarrow x-u=\text{prox}_{f^*}(x)\text{   (10-1)}
\end{align}</script><p>​            Decomposition:</p>
<script type="math/tex; mode=display">
x=P_L(x)+P_{L^\perp}(x)</script><p>​                    with $f=\delta<em>{L}, f^*=\delta</em>{L^\perp}$ .</p>
<p>​            Extended version</p>
<ul>
<li>Composition with affine mapping</li>
</ul>
<script type="math/tex; mode=display">
f(x)=g(Ax+b)</script><blockquote>
<p>由 g 的近似点映射求  f 的并不容易</p>
<p>但是如果 $AA^T=(1/\alpha)I$ ，则 f 有解析的近似点映射(slides)</p>
</blockquote>
<h2 id="4-Projections"><a href="#4-Projections" class="headerlink" title="4. Projections"></a>4. Projections</h2><blockquote>
<p>近似点映射对各种集合的投影有比较好的性质。例子见slides。</p>
</blockquote>
<h2 id="5-Support-functions-norms-distances"><a href="#5-Support-functions-norms-distances" class="headerlink" title="5. Support functions, norms, distances"></a>5. Support functions, norms, distances</h2><blockquote>
<p>同上，例子见slides。</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>凸优化</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>凸优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Extremely Low Bit Neural Network: Squeeze the Last Bit Out with ADMM</title>
    <url>/2019/02/12/%E8%AE%BA%E6%96%87-Low-bit-quantization/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><a href="https://arxiv.org/pdf/1707.09870.pdf">Extremely Low Bit Neural Network: Squeeze the Last Bit Out with ADMM - 原文</a> ；AAAI 18 Oral。</li>
<li>从结果看比之前的一些量化工作都要好上不少，干货较多。</li>
</ul>
<a id="more"></a>
<h2 id="量化-Quantization"><a href="#量化-Quantization" class="headerlink" title="量化(Quantization)"></a>量化(Quantization)</h2><h3 id="为什么要压缩网络"><a href="#为什么要压缩网络" class="headerlink" title="为什么要压缩网络"></a>为什么要压缩网络</h3><ul>
<li>网络的表达能力过强，压缩网络可以起到一定正则的作用</li>
<li>网络存在很多冗余参数和计算量，压缩网络可以极大减少储存空间以及运算量</li>
</ul>
<h3 id="什么是量化"><a href="#什么是量化" class="headerlink" title="什么是量化"></a>什么是量化</h3><ul>
<li>对权重的参数进行取整，降低存储精度。低精度数不仅减少存储空间，而且能够规避浮点运算带来的巨大计算量。经过特别设计的芯片还能对低精度数的运算（可用速度更快的位运算）进行更进一步的优化。</li>
<li>有几种方法降低精度，常见的方法如直接对权值作聚类分析（更进一步可以对每一个cluster进行Huffman编码，继续压缩存储空间）或是直接添加整数约束/改变激活函数等</li>
</ul>
<p><img src="https://camo.githubusercontent.com/16e9d6bdc804b3204c476a6082bbc72f06db9b6d/68747470733a2f2f696d672d626c6f672e6373646e2e6e65742f3230313631303236313834323333333237" alt=""></p>
<ul>
<li>也可以对梯度和输出量化；对于不同的方法，可能需要专门设计训练过程来计算梯度。</li>
</ul>
<h2 id="ADMM-Alternative-Direction-Multiplier-Method"><a href="#ADMM-Alternative-Direction-Multiplier-Method" class="headerlink" title="ADMM(Alternative Direction Multiplier Method)"></a>ADMM(Alternative Direction Multiplier Method)</h2><ul>
<li>因大规模网络的应用，近年来颇受关注的一种优化方法。虽然ADMM在理论分析中收敛慢，但是在许多实际的大规模应用场景中表现稳定，且较为适合分布式计算。</li>
<li>更进一步的对ADMM的讨论可见<a href="https://thiswinex.github.io/2019/01/28/%E7%AC%94%E8%AE%B0-ADMM-%E4%BA%A4%E6%9B%BF%E6%96%B9%E5%90%91%E4%B9%98%E5%AD%90%E6%B3%95/">另一篇文章</a></li>
</ul>
<h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><ul>
<li>论文实现了将32比特权重压缩至3比特的低比特权重量化。之前的若是要将权重量化到3或更低的比特上的话，在大数据集上效果并不好。</li>
<li>论文只介绍了思路，并没有源码</li>
</ul>
<h3 id="实现算法"><a href="#实现算法" class="headerlink" title="实现算法"></a>实现算法</h3><ul>
<li>将离散权重网络训练定义成离散约束问题，以三值网络为例，约束为：<script type="math/tex; mode=display">\underset{W}{\min}\ f(W)\ \ s.t.W\in \mathcal{C}=\{1,0,-1\}^d</script></li>
<li>引进 scale 参数扩展可行域，将约束条件扩展至 $W\in \mathcal{C}={a,0,-a}$ 。由于约束空间变大（如下图），收敛速度将大大加快。<ul>
<li>注意这里之后再 scale 回去严格二值的话，实际上是会损失精度，这样量化出来的BWN只能算作变种（参考XNOR Net）</li>
<li>个人有点怀疑这样部署到端上后的效果。有些端不支持高位数的scale参数的存储和计算。</li>
</ul>
</li>
</ul>
<p><img src="https://camo.githubusercontent.com/8a5b07526e6e12e6b0c7cc8538e72f35711a58df/68747470733a2f2f696d6167652e6a6971697a686978696e2e636f6d2f75706c6f6164732f656469746f722f66643965633961632d353064642d343836372d623762622d6238306261666431366335312f353137393630332e6a7067" alt=""></p>
<ul>
<li><p>使用ADMM算法一般约束下的形式，将问题转换为：</p>
<script type="math/tex; mode=display">\underset{W,G}{\min}\ f(W)+I_C(G)\ \ s.t.W=G</script><p>其中 $I_C$ 为指示函数，$G$ 符合约束则为0，否则为无穷大。</p>
<p>其拉格朗日函数形式为：</p>
<script type="math/tex; mode=display">L_\rho(W,G,\lambda)=f(W)+I_C(G)+\frac{\rho}{2}||W-G+\lambda||^2-\frac{\rho}{2}||\lambda||^2</script><p>迭代过程：</p>
<script type="math/tex; mode=display">
\begin{align}
W^{k+1}&:=\arg\min_W L_\rho(W, G^k, \lambda^k)\\
G^{k+1}&:=\arg\min_G L_\rho(W^{k+1}, G, \lambda^k)\\
\lambda^{k+1}&:=\lambda^k+W^{k+1}-G^{k+1}
\end{align}</script></li>
<li><p>对第一个对 $W$ 更新的过程，采用 Extra-gradient 算法进行梯度下降能够避免收敛过慢的问题：</p>
<script type="math/tex; mode=display">
\begin{align}
W^{(p)}&:=W-\beta_p\partial_WL(W)\\
W^{(c)}&:=W-\beta_c\partial_WL(W^{(p)})
\end{align}</script><ul>
<li>Extra-gradient method 即外梯度算法，由 Korpelevich 提出（可见原文引文[23]）。这篇论文距今已经40年了，既难找又难懂，感觉又是个新坑……涉及变分不等式的部分可以和ADMM一起又单写一篇文章了。</li>
<li>（学习完凸优化后补充）其实也不是很复杂，如果不关心数学图景上的原理的话，可以看做用下一步的梯度来取代这一步的梯度做梯度下降。单步计算量和存储量都会更高，但是会获得相对更正确的下降方向。</li>
</ul>
</li>
<li>对第二个对 $G$ 更新的过程，我们可以将其看做在非凸集上整数约束的优化问题。令 $W_i, G_i, \lambda_i, \mathcal{C}_i$ 分别为第 $i$ 层权重、辅助变量、拉格朗日乘子和约束集合。根据ADMM算法，迭代时需要计算在 $\mathcal{C}_i$ 上 $W^{k+1}_i+\lambda^k_i$的欧式投影。令 $V_i=W^{k+1}_i+\lambda^k_i$ ，其欧式投影可以表示为：<script type="math/tex; mode=display">\min_{G_i,\alpha_i} ||V_i-G_i||^2</script><script type="math/tex; mode=display">s.t. G_i\in\{0,\pm\alpha_i, \pm 2\alpha, \cdots, \pm 2^N\alpha\}^{d_i}</script>从约束中分离 scale 参数：<script type="math/tex; mode=display">\min_{Q_i,\alpha_i} ||V_i-\alpha_i\cdot Q_i||^2</script><script type="math/tex; mode=display">s.t. Q_i\in\{0,\pm, \pm 2, \cdots, \pm 2^N\}^{d_i}</script>算法交替优化 $Q_i$ 和 $\alpha_i$ 中的其中一个而固定另外一个：<ul>
<li>在 $Q_i$ 固定时：<script type="math/tex; mode=display">\alpha_i=\frac{V^T_i Q_i}{Q^T_i Q_I}</script></li>
<li>在 $\alpha_i$ 固定时：<script type="math/tex; mode=display">Q_i=\Pi_{\{0,\pm 1,\pm 2,\cdots,\pm 2^N\}}(\frac{V_i}{\alpha_i})</script>对 $Q_i$ 的更新，$\Pi$ 投影只是简单地取离约束集合最近的点（参见ADMM笔记4.3.5）。</li>
</ul>
</li>
<li>这种迭代算法能保证很快收敛到局部极小值。</li>
<li>最后迭代停止时，直接用 $G$ 取代 $W$ 即可。</li>
</ul>
<h3 id="论文结果"><a href="#论文结果" class="headerlink" title="论文结果"></a>论文结果</h3><ul>
<li>算法在AlexNet、VGG、ResNet、GoogleNet上均做了测试，2~3bit的量化相比state-of-art 的一些二值网络与三值网络高出有1~4%的Top5正确率，只比全精度的baseline低1%多一些。</li>
</ul>
]]></content>
      <categories>
        <category>论文</category>
        <category>NN压缩与加速</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>论文</tag>
        <tag>NN压缩与加速</tag>
      </tags>
  </entry>
  <entry>
    <title>8. 次梯度</title>
    <url>/2019/06/05/%E7%AC%94%E8%AE%B0-%E6%AC%A1%E6%A2%AF%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="Sub-Gradient"><a href="#Sub-Gradient" class="headerlink" title="Sub-Gradient"></a>Sub-Gradient</h2><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><ul>
<li>介绍了次梯度的一些性质，为之后的次梯度方法作铺垫。</li>
</ul>
<a id="more"></a>
<h2 id="1-Sub-Gradient"><a href="#1-Sub-Gradient" class="headerlink" title="1. Sub-Gradient"></a>1. Sub-Gradient</h2><p>$g$ is a sub-gradient of convex function $f$ if</p>
<script type="math/tex; mode=display">
f(y)\geq f(x)+g^T(y-x), \forall y\in \textbf{dom} f</script><h3 id="1-1-Properties"><a href="#1-1-Properties" class="headerlink" title="1.1 Properties"></a>1.1 Properties</h3><ul>
<li>unconstrained optimality: $x$ minimize $f(x)$ if $0\in\partial f(x)$</li>
</ul>
<h3 id="1-2-Subdifferential"><a href="#1-2-Subdifferential" class="headerlink" title="1.2 Subdifferential"></a>1.2 Subdifferential</h3><p>a set of all sub-gradient:</p>
<script type="math/tex; mode=display">
\partial f(x)=\{g\mid g^T(y-x)\leq f(y)-f(x),\forall y\in\textbf{dom}f\}</script><blockquote>
<p>$\partial f(x)$ 是半空间的交，所以是凸闭集</p>
</blockquote>
<h3 id="1-3-Monotonicity"><a href="#1-3-Monotonicity" class="headerlink" title="1.3 Monotonicity"></a>1.3 Monotonicity</h3><blockquote>
<p>次梯度在凸函数上单调(类比梯度)</p>
</blockquote>
<h3 id="1-4-Sub-level-set"><a href="#1-4-Sub-level-set" class="headerlink" title="1.4 Sub-level set"></a>1.4 Sub-level set</h3><blockquote>
<p>$x$ 上的非零次梯度定义了此处下水平集的一个支撑超平面</p>
</blockquote>
<h2 id="2-Sub-Gradient-calculus"><a href="#2-Sub-Gradient-calculus" class="headerlink" title="2. Sub-Gradient calculus"></a>2. Sub-Gradient calculus</h2><ul>
<li>weak result: find <strong>1</strong> sub-gradient </li>
<li>strong result: find <strong>all</strong> sub-gradient</li>
</ul>
<h3 id="2-1-Basic-rules"><a href="#2-1-Basic-rules" class="headerlink" title="2.1 Basic rules"></a>2.1 Basic rules</h3><ul>
<li><p>Differentiable functions:</p>
<p>$\partial f(x)={\triangledown f(x)}$ if $f$ is differentiable at $x$</p>
</li>
<li><p>Non-negative linear combination (Thm. Morean-Rockafellor):</p>
<p>if $f(x)=\alpha_1f_1(x)+\alpha_2f_2(x)\text{ with } \alpha_1、\alpha_2\geq0$</p>
<p>than $\partial f(x)=\alpha_1\partial f_1(x)+\alpha_2\partial f_2(x)$</p>
</li>
<li><p>Affine transformation of variables:</p>
<p>if $f(x)=h(Ax+b)$</p>
<p>then $\partial f(x)=A^T\partial h(Ax+b)$</p>
</li>
</ul>
<h3 id="2-2-Pointwise-maximum"><a href="#2-2-Pointwise-maximum" class="headerlink" title="2.2 Pointwise maximum"></a>2.2 Pointwise maximum</h3><ul>
<li><p>$f(x)=\max{f_1(x),\cdots,f_m(x)}$。 Define $I(x)={i\mid f(x)=f_i(x)}$</p>
</li>
<li><p>weak result: choose $k\in I(x)$ ， any sub-gradient in $f_k(x)$  </p>
</li>
<li><p>strong result: (Dubovitskii-Milyutin)</p>
<script type="math/tex; mode=display">
\partial f(x)=\text{conv} \bigcup_{i=I(x)}\partial f_i(x)</script></li>
</ul>
<blockquote>
<p>在同一点可能有多个函数f被激活</p>
</blockquote>
<ul>
<li>Exp. 1-norm</li>
</ul>
<h3 id="2-3-Maximum-eigenvalue"><a href="#2-3-Maximum-eigenvalue" class="headerlink" title="2.3 Maximum eigenvalue"></a>2.3 Maximum eigenvalue</h3><ul>
<li><p>$f(x)=\lambda<em>{max}(A(x))=\sup</em>{|y|_2=1}y^TA(x)y$</p>
<p>where $A(x)=A_0+x_1A_1+\cdots+x_nA_n$</p>
<p><strong>Find</strong> a sub-gradient in $\hat{x}$</p>
</li>
<li><p>choose any unit eigenvalue $y$ with eigenvalue $\lambda_{max}(A(x))$ </p>
</li>
<li><p>gradient of $y^TA(x)y$ is an answer:</p>
<p>$(y_1^TAy_1,\cdots,y^T_nAy_n)\in \partial f(x)$ </p>
</li>
</ul>
<h3 id="2-4-Some-other-examples"><a href="#2-4-Some-other-examples" class="headerlink" title="2.4 Some other examples"></a>2.4 Some other examples</h3><ul>
<li><p>minimize $f(x)=\inf_yh(x,y)$ </p>
</li>
<li><p>minimize $f(x)=\inf_{y\in C} |x-y|_2$ , which $C$ is convex.</p>
</li>
<li><p>Composition: $f(x)=h(f_1(x),\cdots,f_k(x))$ , which $f_i, h$ is convex, $h$ non-decreasing.</p>
</li>
<li><p>Optimal value function:</p>
<p>considering minimize $f_0(x)$</p>
<p>s.t. $f_i(x)&lt;u_i, Ax=b+v$</p>
<p>With strong duality, finite dual problem: $f(\hat{u},\hat{v})$ is optimal, we can conclude that $(-\hat{\lambda},-\hat{\nu})\in \partial f(\hat{u},\hat{v})$ </p>
<blockquote>
<ul>
<li><p>$\lambda,\nu$ 是拉格朗日对偶对应项的系数梯度</p>
</li>
<li><p>$u\in \partial f(v) \Leftrightarrow v\in \partial f^*(u)\tag{8-1}$</p>
</li>
<li>极小值问题转为次梯度问题(?)</li>
</ul>
</blockquote>
</li>
<li><p>Expectation </p>
</li>
</ul>
<h2 id="3-Optimal-condition"><a href="#3-Optimal-condition" class="headerlink" title="3. Optimal condition"></a>3. Optimal condition</h2><ul>
<li>$x^\star$ minimize $f(x)$ iff $0\in \partial f(x^\star)$</li>
</ul>
<h3 id="Constrained"><a href="#Constrained" class="headerlink" title="Constrained"></a>Constrained</h3><p>KKT Condition: dual optimal iff</p>
<ul>
<li>Strong duality holds</li>
<li>$x^\star$ is primal feasible</li>
<li>$\lambda^\star\geq 0$   </li>
<li>$\lambda_i^\star f_i(x^\star)=0$ for $i=1,\cdots,m$</li>
<li>$x^\star$ minimize the $L(x,\lambda^\star)$</li>
</ul>
<h2 id="4-Directional-derivative"><a href="#4-Directional-derivative" class="headerlink" title="4. Directional derivative"></a><strong>4. Directional derivative</strong></h2><ul>
<li>Definition: ($f$ at $x$ with $y$ direction)</li>
</ul>
<script type="math/tex; mode=display">
f'(x;y)=\lim_{\alpha\rightarrow0}\frac{f(x+\alpha y)-f(x)}{\alpha}</script>]]></content>
      <categories>
        <category>笔记</category>
        <category>凸优化</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>凸优化</tag>
      </tags>
  </entry>
  <entry>
    <title>非root权限下安装zsh</title>
    <url>/2020/03/09/%E9%9D%9Eroot%E6%9D%83%E9%99%90%E4%B8%8B%E5%AE%89%E8%A3%85zsh/</url>
    <content><![CDATA[<a id="more"></a>
<p>选修课分到的服务器虽然环境配好，但是默认shell是bash，<a href="https://www.bilibili.com/video/av911093/">我不能忍</a>。locate了一下，发现两年前服务器上也有个人不能忍，第一次上线啥都没干，就装了个zsh。偷瞄了一下bash_history，他应该看的这篇教程：</p>
<p><a href="https://www.drewsilcock.co.uk/compiling-zsh">Compiling zsh without root</a></p>
<p>因为第一次wget zsh后解压+configure，会发现ncurses的报错，所以先要把对应的ncurses装好（具体版本根据服务器系统而定），然后调环境变量让编译器认得路就行了。一般来说用不到icmake和yodl（参考github上一个更简单的<a href="https://gist.github.com/mgbckr/b8dc6d7d228e25325b6dfaa1c4018e78">脚本</a>）。</p>
<p>当然，如果还不行，就老实安装icmake，按照教程做吧。</p>
]]></content>
      <categories>
        <category>杂物</category>
      </categories>
      <tags>
        <tag>杂物</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 题解记录(2)</title>
    <url>/2019/08/26/OJ-LeetCode%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-2/</url>
    <content><![CDATA[<p>分享一些自己LeetCode题目的题解。</p>
<p>*标记的题目为待优化题目。</p>
<a id="more"></a>
<h3 id="565-Medium-数组嵌套-Array-Nesting"><a href="#565-Medium-数组嵌套-Array-Nesting" class="headerlink" title="#565 [Medium] 数组嵌套 Array Nesting"></a>#565 [Medium] 数组嵌套 <a href="https://leetcode-cn.com/problems/array-nesting/">Array Nesting</a></h3><blockquote>
<p>索引从0开始长度为N的数组A，包含0到N - 1的所有整数。找到并返回最大的集合S，S[i] = {A[i], A[A[i]], A[A[A[i]]], … }且遵守以下的规则。</p>
<p>假设选择索引为i的元素A[i]为S的第一个元素，S的下一个元素应该是A[A[i]]，之后是A[A[A[i]]]… 以此类推，不断添加直到S出现重复的元素。</p>
</blockquote>
<p>又用暴力解了一次。。虽然很难受但是确实也有用。。</p>
<p>看起来像是一个图论题找最大环，但相比普通图来说这个图有更多的性质——所有节点的出入度都为1，即图里面只有环，那么每个环只需要检索一次。利用这个性质可以作标记降低搜索复杂度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">arrayNesting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> deep = <span class="number">0</span>, index = i;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">//去掉</span></span><br><span class="line">            <span class="keyword">bool</span> is_find = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vec.size();j++)&#123; <span class="comment">//去掉</span></span><br><span class="line">                    <span class="keyword">if</span>(nums[index] == vec[j] || nums[index] == <span class="number">-1</span>) &#123; <span class="comment">//去掉第一个条件</span></span><br><span class="line">                        is_find = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(is_find) <span class="keyword">break</span>;</span><br><span class="line">                vec.push_back(nums[index]); <span class="comment">//去掉</span></span><br><span class="line">                <span class="keyword">int</span> pre_index = index;</span><br><span class="line">                index = nums[index];</span><br><span class="line">                nums[pre_index] = <span class="number">-1</span>;</span><br><span class="line">                deep++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(deep &gt; ans) ans = deep;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :1244 ms, 在所有 C++ 提交中击败了5.35%的用户</p>
<p>内存消耗 :10.7 MB, 在所有 C++ 提交中击败了78.26%的用户</p>
</blockquote>
<p>然后发现这个时间也太TM奇怪了吧。。看了一下自己算法逻辑有点问题，对一些代码做了点优化（如注释）：</p>
<blockquote>
<p>执行用时 :28 ms, 在所有 C++ 提交中击败了63.64%的用户</p>
<p>内存消耗 :9.8 MB, 在所有 C++ 提交中击败了88.41%的用户</p>
</blockquote>
<p>这下舒服了。。</p>
<hr>
<h3 id="984-Medium-不含AAA或BBB的字符串-String-Without-AAA-or-BBB"><a href="#984-Medium-不含AAA或BBB的字符串-String-Without-AAA-or-BBB" class="headerlink" title="#984 [Medium] 不含AAA或BBB的字符串 String Without AAA or BBB"></a>#984 [Medium] 不含AAA或BBB的字符串 <a href="https://leetcode-cn.com/problems/string-without-aaa-or-bbb/">String Without AAA or BBB</a></h3><blockquote>
<p>给定两个整数 A 和 B，返回任意字符串 S，要求满足：</p>
<p>S 的长度为 A + B，且正好包含 A 个 ‘a’ 字母与 B 个 ‘b’ 字母；<br>子串 ‘aaa’ 没有出现在 S 中；<br>子串 ‘bbb’ 没有出现在 S 中。</p>
</blockquote>
<p>直接构造即可。不妨设 $A&gt;B$ ，那么只需要特殊考虑 <code>A/B&gt;2</code>  的情况即可，剩下的字符串用 <code>A%B</code> 来构造。</p>
<p>更直观的构造使用计数器，哪个剩余字符多写哪个字符，用一个标记来阻止程序连写三个符号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">strWithout3a3b</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m_A, m_B;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="built_in">string</span> m_a_char, m_b_char;</span><br><span class="line">        <span class="keyword">if</span>(A &gt; B) &#123; m_A = A; m_B = B; m_a_char = <span class="string">&quot;a&quot;</span>; m_b_char = <span class="string">&quot;b&quot;</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; m_A = B; m_B = A; m_a_char = <span class="string">&quot;b&quot;</span>; m_b_char = <span class="string">&quot;a&quot;</span>;&#125;</span><br><span class="line">        <span class="built_in">string</span> tri = m_a_char+m_a_char+m_b_char, duo = m_a_char+m_b_char;</span><br><span class="line">        <span class="keyword">if</span>(m_A / m_B &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> res = m_A%m_B;</span><br><span class="line">            <span class="keyword">while</span>(res &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans += tri;</span><br><span class="line">                res--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(ans.length() &lt; A+B)&#123;</span><br><span class="line">                ans += duo;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(ans.length() +<span class="number">2</span> &lt; A+B)</span><br><span class="line">                ans += tri;</span><br><span class="line">            <span class="keyword">while</span>(ans.length() &lt; A+B)</span><br><span class="line">                ans += m_a_char;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :12 ms, 在所有 C++ 提交中击败了30.65%的用户</p>
<p>内存消耗 :8.7 MB, 在所有 C++ 提交中击败了81.08%的用户</p>
</blockquote>
<hr>
<h3 id="42-Hard-接雨水"><a href="#42-Hard-接雨水" class="headerlink" title="#42 [Hard] 接雨水"></a>#42 [Hard] 接雨水</h3><blockquote>
<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
</blockquote>
<p>栈主题训练。先用暴力试一下：对每一层迭代，单独计算每一层中能容纳的雨水量，这样暴力会超时而且和栈似乎没什么关系。。复杂度是 $O(mn)$ ，$m$ 为柱子的最高高度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> isBreak = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!isBreak)&#123;</span><br><span class="line">            <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">            isBreak = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;height.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(height[i<span class="number">-1</span>] &gt; <span class="number">0</span> &amp;&amp; height[i] == <span class="number">0</span>) stk.push(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(stk.size() &gt; <span class="number">0</span> &amp;&amp; height[i] == <span class="number">0</span>) &#123; stk.top()++; &#125;</span><br><span class="line">                <span class="keyword">if</span>(height[i<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; height[i] &gt; <span class="number">0</span> &amp;&amp; stk.size() &gt; <span class="number">0</span>) </span><br><span class="line">                &#123; ans += stk.top(); stk.pop(); &#125;</span><br><span class="line">                <span class="keyword">if</span>(height[i<span class="number">-1</span>] &gt; <span class="number">0</span>) height[i<span class="number">-1</span>]--;</span><br><span class="line">                <span class="keyword">if</span>(height[i<span class="number">-1</span>] &gt; <span class="number">0</span>) isBreak = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(height[height.size()<span class="number">-1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">                height[height.size()<span class="number">-1</span>]--; </span><br><span class="line">            <span class="keyword">if</span>(height[height.size()<span class="number">-1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">                isBreak = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>新的暴力法，对每个柱子，检索两侧的最高柱子，可以得到这个柱子上的承水量。复杂度 $O(n^2)$ 感觉和上面的差不太多，应该也会被卡时间。</p>
<p>如果先遍历一遍数组，就可以找到每个元素上向左(向右)的最高柱子，不需要对每根柱子都检索一遍，这样复杂度应该可以到 $O(n)$ 了。</p>
<p>使用栈的算法，找到比栈顶低的元素入栈，找到比栈顶高的元素则栈顶弹出，使用当前元素、原栈顶高度和新栈顶高度进行水量计算。复杂度同样是 $O(n)$ 。</p>
<p>双指针法和上面两种思路差不多，同样是单次遍历。由于短板效应，只有在leftMAX &lt; rightMAX 的时候才是左指针向右遍历，否则反之。遍历的时候更新响应的MAX值，并用MAX值减去当前高度作为水量加到答案上。复杂度 $O(n)$ 。</p>
<p>Tips：在存在一个数组height的情况下，关于index的数据结构能同时保存index和响应值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        stk.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;height.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(height[i] &lt;= height[stk.top()]) &#123;</span><br><span class="line">                stk.push(i); <span class="comment">//推入index</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(height[i] &gt; height[stk.top()])&#123;</span><br><span class="line">                        <span class="keyword">int</span> height_now = height[stk.top()];</span><br><span class="line">                        stk.pop();</span><br><span class="line">                        <span class="keyword">if</span>(stk.empty()) <span class="keyword">break</span>;</span><br><span class="line">                        ans += (min(height[i], height[stk.top()])-height_now) * (i-stk.top()<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                stk.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :16 ms, 在所有 C++ 提交中击败了23.61%的用户</p>
<p>内存消耗 :9.1 MB, 在所有 C++ 提交中击败了78.77%的用户</p>
</blockquote>
<hr>
<h3 id="84-Hard-柱状图中的最大矩形"><a href="#84-Hard-柱状图中的最大矩形" class="headerlink" title="#84 [Hard] 柱状图中的最大矩形"></a>#84 [Hard] 柱状图中的最大矩形</h3><blockquote>
<p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
</blockquote>
<p>真正的Hard应该是做不出来的。。</p>
<p>核心问题可以看做求每个柱子的最大等高线宽度。应该是卡了 $O(n^2)$ 的暴力，需要用一些方法优化。我这里维护了一个数组<code>left_w</code>和一个栈<code>stk</code>，<code>stk</code>是一个单调增的柱子序列的index（index也单增），一旦检索到比<code>top</code>元素小的元素，则循环出栈直到新元素能入栈，并处理出栈元素对答案的更新（由于新元素小于出栈元素，出栈元素的右向宽度计数在此终止）。由于是右向检索，还需要<code>left_w</code>数组来维护新元素左向的宽度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(heights.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left_w</span><span class="params">(heights.size())</span></span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        stk.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;heights.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(heights[i] &gt;= heights[stk.top()]) stk.push(i); <span class="comment">//大于栈顶元素则入栈</span></span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; heights[i] &lt;  heights[stk.top()])&#123;<span class="comment">//栈空或当前元素大于栈顶元素停止循环</span></span><br><span class="line">                ans = max(ans, (i-stk.top()+left_w[stk.top()])*heights[stk.top()]);<span class="comment">//更新ANS</span></span><br><span class="line">                left_w[i] = i-stk.top()+left_w[stk.top()];<span class="comment">//更新LEFT_W</span></span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(i); <span class="comment">//入栈(好像重复了但是还是AC了。。)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stk.empty())&#123;<span class="comment">//遍历完之后若栈非空的处理</span></span><br><span class="line">            <span class="keyword">int</span> i = heights.size();</span><br><span class="line">            ans = max(ans, (i-stk.top()+left_w[stk.top()])*heights[stk.top()]);</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :36 ms, 在所有 C++ 提交中击败了14.06%的用户</p>
<p>内存消耗 :10.8 MB, 在所有 C++ 提交中击败了7.44%的用户</p>
</blockquote>
<p>(明明是 $O(n)$ 的算法，却有着堪比 $O(n^2)$ 的实现。。)</p>
<p>其他方法：</p>
<ul>
<li><p>分治：(最坏 $O(n^2)$ 平均 $O(n\log n)$ ，可用线段树优化)</p>
<ul>
<li>确定了最矮柱子以后，矩形的宽尽可能往两边延伸。</li>
<li>在最矮柱子左边的最大面积矩形（子问题）。</li>
<li>在最矮柱子右边的最大面积矩形（子问题）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="215-Medium-数组中的第K个最大元素-Kth-Largest-Element-in-an-Array"><a href="#215-Medium-数组中的第K个最大元素-Kth-Largest-Element-in-an-Array" class="headerlink" title="#215* [Medium] 数组中的第K个最大元素 Kth Largest Element in an Array"></a>#215* [Medium] 数组中的第K个最大元素 <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">Kth Largest Element in an Array</a></h3><blockquote>
<p>在未排序的数组中找到第 <strong>k</strong> 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
</blockquote>
<p>我这里是使用了堆排，排序好久没写了手生。。实际上不需要排序，只需要维护k大小的小顶堆即可，时间复杂度还能优化一下。</p>
<p>同样用快排的话，不需要对pivot两边递归排序。因为每次都知道pivot是第几大的元素，所以可以直接选择一边而放弃另一边。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">heap</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            heap[i] = nums[i];</span><br><span class="line">            <span class="comment">//cout&lt;&lt;&quot;Push: &quot;&lt;&lt;nums[i]&lt;&lt;endl;</span></span><br><span class="line">            <span class="comment">//shiftUp(heap, i);</span></span><br><span class="line">        &#125;</span><br><span class="line">        sort(heap, k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;heap.size();i++) <span class="built_in">cout</span>&lt;&lt;heap[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> heap[heap.size()-k];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heap, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> parent = start;</span><br><span class="line">        <span class="keyword">int</span> son = parent*<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(son &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(son + <span class="number">1</span> &lt;= end &amp;&amp; heap[son] &lt; heap[son+<span class="number">1</span>]) son++;</span><br><span class="line">            <span class="keyword">if</span>(heap[parent] &gt; heap[son]) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                swap(heap[parent], heap[son]);</span><br><span class="line">                parent = son;</span><br><span class="line">                son = parent*<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heap, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = heap.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            shiftUp(heap, i, len<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=len-k;i--)&#123;</span><br><span class="line">            swap(heap[<span class="number">0</span>],heap[i]);</span><br><span class="line">            shiftUp(heap, <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :40 ms, 在所有 C++ 提交中击败了35.47%的用户</p>
<p>内存消耗 :9.3 MB, 在所有 C++ 提交中击败了67.49%的用户</p>
</blockquote>
<hr>
<h3 id="55-Medium-跳跃游戏-Jump-Game"><a href="#55-Medium-跳跃游戏-Jump-Game" class="headerlink" title="#55 [Medium] 跳跃游戏 Jump Game"></a>#55 [Medium] 跳跃游戏 <a href="https://leetcode-cn.com/problems/jump-game/">Jump Game</a></h3><blockquote>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
</blockquote>
<p>贪心训练。感觉贪心的难点在于判断贪心。。所以在已知贪心的情况下并不是很难。。</p>
<p>从当前步一直往下一个位置迭代，循环更新能够到达的最远位置，直到当前位置达到数组长度/最远位置为止。对最远位置进行判断即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dis = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dis &amp;&amp; i&lt;nums.size();i++)&#123;</span><br><span class="line">            dis = max(dis, i+nums[i]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dis &lt; nums.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :24 ms, 在所有 C++ 提交中击败了24.26%的用户</p>
<p>内存消耗 :9.9 MB, 在所有 C++ 提交中击败了72.19%的用户</p>
</blockquote>
<hr>
<h3 id="122-Easy-买卖股票的最佳时机II-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Easy-买卖股票的最佳时机II-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="#122 [Easy] 买卖股票的最佳时机II Best Time to Buy and Sell Stock II"></a>#122 [Easy] 买卖股票的最佳时机II <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">Best Time to Buy and Sell Stock II</a></h3><blockquote>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
</blockquote>
<p>贪心一时爽，一直贪心一直爽。。</p>
<p>把递增的部分的差全部加起来就好了。未来股价都给你了，烂钱还不会恰么。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.size()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            profit += max(prices[i+<span class="number">1</span>] - prices[i], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :12 ms, 在所有 C++ 提交中击败了53.04%的用户</p>
<p>内存消耗 :9.6 MB, 在所有 C++ 提交中击败了7.50%的用户</p>
</blockquote>
<hr>
<h3 id="45-Hard-跳跃游戏II-Jump-Game-II"><a href="#45-Hard-跳跃游戏II-Jump-Game-II" class="headerlink" title="#45 [Hard] 跳跃游戏II Jump Game II"></a>#45 [Hard] 跳跃游戏II <a href="https://leetcode-cn.com/problems/jump-game-ii/">Jump Game II</a></h3><blockquote>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
</blockquote>
<p>一样的，难点在于分析贪心性质。容易知道，对于当前步能走到的位置来说，下一步走最大的位置总是没错的（没有其他选择能比其覆盖了更多的选择）。</p>
<p>写到这里突然想到贪心和DP的一些小区别，一些具有贪心性质的问题，本质在于一些最优的下一步状态，本身还包含着最多的状态选择。这样从全局观点来看，这种局部最优的状态转移也是永远正确的（我的状态比你好，可选状态也比你多）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dis = <span class="number">1</span>, new_dis = <span class="number">1</span>, min_step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=dis)&#123;</span><br><span class="line">                min_step++;</span><br><span class="line">                dis = new_dis;</span><br><span class="line">            &#125;</span><br><span class="line">            new_dis = max(new_dis, i+nums[i]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :20 ms, 在所有 C++ 提交中击败了32.55%的用户</p>
<p>内存消耗 :10 MB, 在所有 C++ 提交中击败了88.36%的用户</p>
</blockquote>
<hr>
<h3 id="56-Medium-合并区间"><a href="#56-Medium-合并区间" class="headerlink" title="#56 [Medium] 合并区间"></a>#56 [Medium] 合并区间</h3><blockquote>
<p>给出一个区间的集合，请合并所有重叠的区间。</p>
</blockquote>
<p>排序就完事了。区间头尾分两个数组排序，坏处是占空间多。如果排序后的头/尾数组上有关系：$start[i+1]&gt;end[i]$ ，则 $end[i]$ 为一段合并区间的尾。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(intervals.size() == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">start</span><span class="params">(intervals.size())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">end</span><span class="params">(intervals.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;intervals.size();i++)&#123;</span><br><span class="line">            start[i] = intervals[i][<span class="number">0</span>];</span><br><span class="line">            end[i] = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(start, <span class="number">0</span>, start.size()<span class="number">-1</span>);</span><br><span class="line">        quickSort(end, <span class="number">0</span>, end.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> l = start[<span class="number">0</span>], r = end[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;start.size()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(end[i] &lt; start[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                r = end[i];</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;l, r&#125;;</span><br><span class="line">                ans.push_back(vec);</span><br><span class="line">                l = start[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec&#123;l, end[end.size()<span class="number">-1</span>]&#125;;</span><br><span class="line">        ans.push_back(vec);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> leftmark = left, rightmark = right, pivot = a[right];</span><br><span class="line">            <span class="keyword">while</span>(leftmark &lt; rightmark)&#123;</span><br><span class="line">                <span class="keyword">while</span>(a[leftmark] &lt;= pivot &amp;&amp; leftmark &lt; rightmark) leftmark++;</span><br><span class="line">                <span class="keyword">if</span>(leftmark &lt; rightmark) a[rightmark--] = a[leftmark];</span><br><span class="line">                <span class="keyword">while</span>(a[rightmark] &gt; pivot &amp;&amp; leftmark &lt; rightmark) rightmark--;</span><br><span class="line">                <span class="keyword">if</span>(leftmark &lt; rightmark) a[leftmark++] = a[rightmark];</span><br><span class="line">            &#125;</span><br><span class="line">            a[rightmark] = pivot;</span><br><span class="line">            quickSort(a, left, rightmark<span class="number">-1</span>);</span><br><span class="line">            quickSort(a, rightmark+<span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :32 ms, 在所有 C++ 提交中击败了63.52%的用户</p>
<p>内存消耗 :12.8 MB, 在所有 C++ 提交中击败了5.08%的用户</p>
</blockquote>
<hr>
<h3 id="136-Easy-只出现一次的数字-Single-Number"><a href="#136-Easy-只出现一次的数字-Single-Number" class="headerlink" title="#136 [Easy] 只出现一次的数字 Single Number"></a>#136 [Easy] 只出现一次的数字 <a href="https://leetcode-cn.com/problems/single-number/">Single Number</a></h3><blockquote>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
</blockquote>
<p>位运算入门题，我想都没想直接写了个逐个异或，然后竟然AC了。。</p>
<p>查了一下是因为一个简单而重要的性质，一个数和另一个数异或两次之后等于它自己。另外，异或运算满足分配律和交换律。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            ans = ans^nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :20 ms, 在所有 C++ 提交中击败了59.35%的用户</p>
<p>内存消耗 :9.6 MB, 在所有 C++ 提交中击败了67.52%的用户</p>
</blockquote>
<hr>
<h3 id="461-Easy-汉明距离-Hamming-Distance"><a href="#461-Easy-汉明距离-Hamming-Distance" class="headerlink" title="#461 [Easy] 汉明距离 Hamming Distance"></a>#461 [Easy] 汉明距离 <a href="https://leetcode-cn.com/problems/hamming-distance/">Hamming Distance</a></h3><blockquote>
<p>两个整数之间的<a href="https://baike.baidu.com/item/汉明距离">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p>
</blockquote>
<p>异或后用移位来计数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = x^y;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num % <span class="number">2</span> != <span class="number">0</span>) ans++;</span><br><span class="line">            num&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :4 ms, 在所有 C++ 提交中击败了74.90%的用户</p>
<p>内存消耗 :8.2 MB, 在所有 C++ 提交中击败了81.46%的用户</p>
</blockquote>
<hr>
<h3 id="169-Easy-求众数-Majority-Element"><a href="#169-Easy-求众数-Majority-Element" class="headerlink" title="#169 [Easy] 求众数 Majority Element"></a>#169 [Easy] 求众数 <a href="https://leetcode-cn.com/problems/majority-element/">Majority Element</a></h3><blockquote>
<p>给定一个大小为 <em>n</em> 的数组，找到其中的众数。众数是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p>
</blockquote>
<p>解法很多，直接排序、Hash map都可以。这题的标签有位运算，但是还没想到怎么解，其本质应该是对每一位都取多数。</p>
<p>还有一种BM算法的改版，用计数器计算当前众数的数量，遇到非当前众数则减1，减至零则换众数。由于众数占超过半数，所以真正的众数永远不会被换掉。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// BM Algo</span></span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> score = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != ans) score--;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == ans) score++;</span><br><span class="line">            <span class="keyword">if</span>(score == <span class="number">0</span>) &#123;</span><br><span class="line">                score = <span class="number">1</span>;</span><br><span class="line">                ans = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :44 ms, 在所有 C++ 提交中击败了19.24%的用户</p>
<p>内存消耗 :11 MB, 在所有 C++ 提交中击败了85.94%的用户</p>
</blockquote>
<hr>
<h3 id="62-Medium-不同路径-Unique-Paths"><a href="#62-Medium-不同路径-Unique-Paths" class="headerlink" title="#62 [Medium] 不同路径 Unique Paths"></a>#62 [Medium] 不同路径 <a href="https://leetcode-cn.com/problems/unique-paths/">Unique Paths</a></h3><blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
</blockquote>
<p>备忘录DP。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> **num = <span class="keyword">new</span> <span class="keyword">int</span>*[m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">            num[i] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            num[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) num[<span class="number">0</span>][i] = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                num[i][j] = num[i<span class="number">-1</span>][j] + num[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :4 ms, 在所有 C++ 提交中击败了75.63%的用户</p>
<p>内存消耗 :8.5 MB, 在所有 C++ 提交中击败了40.06%的用户</p>
</blockquote>
<hr>
<h3 id="63-Medium-不同路径-II-Unique-Paths-II"><a href="#63-Medium-不同路径-II-Unique-Paths-II" class="headerlink" title="#63 [Medium] 不同路径 II Unique Paths II"></a>#63 [Medium] 不同路径 II <a href="https://leetcode-cn.com/problems/unique-paths-ii/">Unique Paths II</a></h3><p>加入了障碍物的版本，这里就不细谈了。坑的是数据是卡int类型的，而答案完全没有提到这一点。</p>
<hr>
<h3 id="64-Medium-最小路径和-Minimum-Path-Sum"><a href="#64-Medium-最小路径和-Minimum-Path-Sum" class="headerlink" title="#64 [Medium] 最小路径和 Minimum Path Sum"></a>#64 [Medium] 最小路径和 <a href="https://leetcode-cn.com/problems/minimum-path-sum/">Minimum Path Sum</a></h3><p>最优子问题性质是显然的。不多说。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;grid.size();i++)&#123;</span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;grid[<span class="number">0</span>].size();i++)&#123;</span><br><span class="line">            grid[<span class="number">0</span>][i] += grid[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;grid.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;grid[<span class="number">0</span>].size();j++)&#123;</span><br><span class="line">                 grid[i][j] += min(grid[i<span class="number">-1</span>][j], grid[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[grid.size()<span class="number">-1</span>][grid[<span class="number">0</span>].size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :8 ms, 在所有 C++ 提交中击败了96.38%的用户</p>
<p>内存消耗 :10.3 MB, 在所有 C++ 提交中击败了99.31%的用户</p>
</blockquote>
<hr>
<h3 id="120-Medium-三角形最小路径和-Triangle"><a href="#120-Medium-三角形最小路径和-Triangle" class="headerlink" title="#120 [Medium] 三角形最小路径和 Triangle"></a>#120 [Medium] 三角形最小路径和 <a href="https://leetcode-cn.com/problems/triangle/">Triangle</a></h3><blockquote>
<p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>例如，给定三角形：</p>
<p>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p>
</blockquote>
<p>和#64差不多，最优子问题性质容易证明。附加题是只使用 $O(n)$ 的额外空间，由于最优子问题所需的记事本确实只需要 $O(n)$ 的空间(由上一行递推)，所以这也是比较显然的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// O(n) extra space algorithm?</span></span><br><span class="line">        <span class="keyword">if</span>(triangle.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;triangle.size();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;triangle[i].size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>) triangle[i][j] += triangle[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==i) triangle[i][j] += triangle[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> triangle[i][j] += min(triangle[i<span class="number">-1</span>][j<span class="number">-1</span>], triangle[i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = triangle[triangle.size()<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;triangle[triangle.size()<span class="number">-1</span>].size();i++) </span><br><span class="line">            ans = min(ans, triangle[triangle.size()<span class="number">-1</span>][i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :12 ms, 在所有 C++ 提交中击败了48.68%的用户</p>
<p>内存消耗 :9.5 MB, 在所有 C++ 提交中击败了98.29%的用户</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>习题</category>
        <category>OJ</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>LeetCode</tag>
        <tag>习题</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 题解记录(1)</title>
    <url>/2019/08/05/OJ-LeetCode%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>分享一些自己LeetCode题目的题解。</p>
<p>*标记的题目为待优化题目。</p>
<a id="more"></a>
<h3 id="799-Medium-香槟塔-Champagne-Tower"><a href="#799-Medium-香槟塔-Champagne-Tower" class="headerlink" title="#799 [Medium]香槟塔 Champagne Tower"></a>#799 [Medium]香槟塔 <a href="https://leetcode-cn.com/problems/champagne-tower/">Champagne Tower</a></h3><blockquote>
<p>我们把玻璃杯摆成金字塔的形状，其中第一层有1个玻璃杯，第二层有2个，依次类推到第100层，每个玻璃杯(250ml)将盛有香槟。</p>
<p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p>
<p>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟。</p>
<p>现在当倾倒了非负整数杯香槟后，返回第 i 行 j 个玻璃杯所盛放的香槟占玻璃杯容积的比例（i 和 j都从0开始）。</p>
</blockquote>
<p>香槟的数量范围很大，所以不要想一杯一杯的模拟倾倒。很容易想到香槟的倾倒类似于杨辉三角，但是由于杯子最大容量为1，满了就会溢出，所以也不完全类似。一个简单的方案是对杯子遍历，先把杨辉三角存入杯子数组中，然后把溢出来的部分平均分给下面的杯子。这样从上到下遍历一遍就能得到正确的答案。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">champagneTower</span><span class="params">(<span class="keyword">int</span> poured, <span class="keyword">int</span> query_row, <span class="keyword">int</span> query_glass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fully_layer = <span class="built_in">floor</span>(log2(poured+<span class="number">1</span>))<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> rest_poured = poured - (<span class="built_in">pow</span>(<span class="number">2</span>, fully_layer+<span class="number">1</span>)<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">double</span> glass[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">memset</span>(glass, <span class="number">0</span>, <span class="keyword">sizeof</span>(glass));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=fully_layer;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                glass[i][j] += ComNum(i, j);</span><br><span class="line">                glass[i+<span class="number">1</span>][j] += (glass[i][j]<span class="number">-1</span>)/<span class="number">2.0</span>;</span><br><span class="line">                glass[i+<span class="number">1</span>][j+<span class="number">1</span>] += (glass[i][j]<span class="number">-1</span>)/<span class="number">2.0</span>;</span><br><span class="line">                glass[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=fully_layer+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">double</span> frac = rest_poured / (<span class="built_in">pow</span>(<span class="number">2</span>, fully_layer+<span class="number">1</span>));</span><br><span class="line">            glass[fully_layer+<span class="number">1</span>][j] += ComNum(fully_layer+<span class="number">1</span>, j)*frac;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(glass[fully_layer+<span class="number">1</span>][j] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                glass[fully_layer+<span class="number">2</span>][j] += (glass[fully_layer+<span class="number">1</span>][j]<span class="number">-1</span>)/<span class="number">2.0</span>;</span><br><span class="line">                glass[fully_layer+<span class="number">2</span>][j+<span class="number">1</span>] += (glass[fully_layer+<span class="number">1</span>][j]<span class="number">-1</span>)/<span class="number">2.0</span>;</span><br><span class="line">                glass[fully_layer+<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=fully_layer+<span class="number">2</span>;i&lt;query_row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(glass[i][j] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    glass[i+<span class="number">1</span>][j] += (glass[i][j]<span class="number">-1</span>)/<span class="number">2.0</span>;</span><br><span class="line">                    glass[i+<span class="number">1</span>][j+<span class="number">1</span>] += (glass[i][j]<span class="number">-1</span>)/<span class="number">2.0</span>;</span><br><span class="line">                    glass[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> ans = glass[query_row][query_glass];</span><br><span class="line">        <span class="keyword">if</span>(ans &gt; <span class="number">1</span>) ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">ComNum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> numerator = <span class="number">1.0</span>, denominator = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            denominator *= (i+<span class="number">1</span>);</span><br><span class="line">            numerator *= (n-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numerator/denominator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :8 ms, 在所有 C++ 提交中击败了98.15%的用户</p>
<p>内存消耗 :8.8 MB, 在所有 C++ 提交中击败了84.62%的用户</p>
</blockquote>
<hr>
<h3 id="235-Easy-二叉搜索树的最近公共祖先-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Easy-二叉搜索树的最近公共祖先-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="#235 [Easy]二叉搜索树的最近公共祖先 Lowest Common Ancestor of a Binary Search Tree"></a>#235 [Easy]二叉搜索树的最近公共祖先<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/"> Lowest Common Ancestor of a Binary Search Tree</a></h3><blockquote>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
</blockquote>
<p>直接用二叉搜索树的性质就行了，这个公共祖先的值必然在两个节点的值之间，递归求解即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *ans;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val)&#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">            ans = lowestCommonAncestor(root, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val)&#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">            ans = lowestCommonAncestor(root, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ans = root;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :84 ms, 在所有 C++ 提交中击败了9.13%的用户</p>
<p>内存消耗 :25.8 MB, 在所有 C++ 提交中击败了49.37%的用户</p>
</blockquote>
<hr>
<h3 id="236-Medium-二叉树的最近公共祖先-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Medium-二叉树的最近公共祖先-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="#236 [Medium]二叉树的最近公共祖先 Lowest Common Ancestor of a Binary Tree"></a>#236 [Medium]二叉树的最近公共祖先 <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">Lowest Common Ancestor of a Binary Tree</a></h3><blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
</blockquote>
<p>用栈存储两个节点的到根节点的序列，序列通过递归求得。最后比较序列即可。一个笨方法。</p>
<p>看了一下其他人分享的题解，也有重建树创建父节点的，DFS的，加布尔标记的，感觉也都不是很聪明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; sp, sq;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        findParent(root, p, sp); <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;---&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        findParent(root, q, sq);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sp.size()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;sq.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; *max, *min;</span><br><span class="line">        TreeNode *ans = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(sp.size() &gt; sq.size()) &#123; max = &amp;sp; min = &amp;sq; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; max = &amp;sq; min = &amp;sp; &#125;</span><br><span class="line">        <span class="keyword">int</span> i, max_size = max-&gt;size(), min_size = min-&gt;size();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;(max_size-min_size) &amp;&amp; ans == <span class="literal">NULL</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max-&gt;top() == min-&gt;top())&#123;</span><br><span class="line">                ans = max-&gt;top();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> max-&gt;pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;max_size &amp;&amp; ans == <span class="literal">NULL</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max-&gt;top() == min-&gt;top())&#123;</span><br><span class="line">                ans = max-&gt;top();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; max-&gt;pop(); min-&gt;pop(); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findParent</span><span class="params">(TreeNode* root, TreeNode* node, <span class="built_in">stack</span>&lt;TreeNode*&gt; &amp;s)</span></span>&#123;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Push &quot;</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == node) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Pop &quot;</span>&lt;&lt;s.top()-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">if</span>(findParent(root-&gt;left, node, s)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">if</span>(findParent(root-&gt;right, node, s)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Pop &quot;</span>&lt;&lt;s.top()-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :40 ms, 在所有 C++ 提交中击败了29.07%的用户</p>
<p>内存消耗 :20.5 MB, 在所有 C++ 提交中击败了6.90%的用户</p>
</blockquote>
<hr>
<h3 id="239-Hard-滑动窗口最大值-Sliding-Window-Maximum"><a href="#239-Hard-滑动窗口最大值-Sliding-Window-Maximum" class="headerlink" title="#239* [Hard]滑动窗口最大值 Sliding Window Maximum"></a>#239* [Hard]滑动窗口最大值 <a href="https://leetcode-cn.com/problems/sliding-window-maximum/">Sliding Window Maximum</a></h3><blockquote>
<p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p>示例:</p>
<p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释: </p>
<p>  滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p>
</blockquote>
<p>$O(nk)$ 的算法非常简单，但是很慢：</p>
<p>执行用时 :156 ms, 在所有 C++ 提交中击败了10.90%的用户</p>
<p>内存消耗 :12.6 MB, 在所有 C++ 提交中击败了98.71%的用户</p>
<p>可以尝试 $O(n)$ 的算法，较为复杂。问题的关键在于在常数时间内处理滑动窗口内的最值。</p>
<hr>
<h3 id="404-Easy-左子叶之和-Sum-of-Left-Leaves"><a href="#404-Easy-左子叶之和-Sum-of-Left-Leaves" class="headerlink" title="#404 [Easy]左子叶之和 Sum of Left Leaves"></a>#404 [Easy]左子叶之和 <a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">Sum of Left Leaves</a></h3><blockquote>
<p>计算给定二叉树的所有左叶子之和。</p>
</blockquote>
<p>直接递归就好，注意左叶子的定义和特殊情况。这里单独讲一下这题是因为才发现LeetCode可以自定义测试用例，可以对一些需要单独讨论的情形进行测试来避免踩坑。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span> || (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left_val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right_val = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">NULL</span>) </span><br><span class="line">            left_val = root-&gt;left-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span> &amp;&amp; (root-&gt;left-&gt;left != <span class="literal">NULL</span> || root-&gt;left-&gt;right != <span class="literal">NULL</span>))</span><br><span class="line">            left_val = sumOfLeftLeaves(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span> &amp;&amp; (root-&gt;right-&gt;left != <span class="literal">NULL</span> || root-&gt;right-&gt;right != <span class="literal">NULL</span>)) </span><br><span class="line">            right_val = sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> left_val + right_val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :4 ms, 在所有 C++ 提交中击败了90.75%的用户</p>
<p>内存消耗 :13.3 MB, 在所有 C++ 提交中击败了96.55%的用户</p>
</blockquote>
<hr>
<h3 id="536-Medium-从字符串生成二叉树-Construct-Binary-Tree-from-String"><a href="#536-Medium-从字符串生成二叉树-Construct-Binary-Tree-from-String" class="headerlink" title="#536 [Medium]从字符串生成二叉树 Construct Binary Tree from String"></a>#536 [Medium]从字符串生成二叉树 <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-string/">Construct Binary Tree from String</a></h3><blockquote>
<p>你需要从一个包括括号和整数的字符串构建一棵二叉树。</p>
<p>输入的字符串代表一棵二叉树。它包括整数和随后的0，1或2对括号。整数代表根的值，一对括号内表示同样结构的子树。</p>
<p>若存在左子结点，则从左子结点开始构建。</p>
</blockquote>
<p>这题只要注意几个点就好，一个是树深度和字符转数字都需要存储(一般用栈)，一个是回溯的判定条件。如果以括号来判定数字的终止，则需要对无括号的单节点树做单独判断。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">str2tree</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;&quot;</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; tree;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">        <span class="keyword">bool</span> isPositive = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> times = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(num.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                        val += times * num.top();</span><br><span class="line">                        times *= <span class="number">10</span>;</span><br><span class="line">                        num.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!isPositive) val = -val;</span><br><span class="line">                    root-&gt;val = val;</span><br><span class="line">                    isPositive = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                        tree.push(root);</span><br><span class="line">                        root-&gt;left = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                        root = root-&gt;left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        tree.push(root);</span><br><span class="line">                        root-&gt;right = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                        root = root-&gt;right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                    root = tree.top();</span><br><span class="line">                    tree.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                isPositive = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                num.push((<span class="keyword">int</span>)(s[i]<span class="number">-48</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(num.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> times = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(num.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                val += times * num.top();</span><br><span class="line">                times *= <span class="number">10</span>;</span><br><span class="line">                num.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!isPositive) val = -val;</span><br><span class="line">            root-&gt;val = val;</span><br><span class="line">            isPositive = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :44 ms, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>内存消耗 :21.9 MB, 在所有 C++ 提交中击败了100.00%的用户</p>
</blockquote>
<hr>
<h3 id="201-Medium-数字范围按位与-Bitwise-AND-of-Numbers-Range"><a href="#201-Medium-数字范围按位与-Bitwise-AND-of-Numbers-Range" class="headerlink" title="#201 [Medium]数字范围按位与 Bitwise AND of Numbers Range"></a>#201 [Medium]数字范围按位与 <a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/">Bitwise AND of Numbers Range</a></h3><blockquote>
<p>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p>
</blockquote>
<p>首先弄清楚题意，是把区间内所有的数字做按位<strong>与</strong> 。实际上只需要处理区间端点即可，由于区间内所有数字在相应位上都是1，结果在这一位才是1，所以对于结果的每一位，这一位为1仅当：</p>
<ol>
<li>端点两数在此位为1</li>
<li>端点两数的差小于此位上对应的二进制数(否则区间内总有一个数在此位上为0)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> m_2, n_2, ans;</span><br><span class="line">        m_2 = biTrans(m);</span><br><span class="line">        n_2 = biTrans(n);</span><br><span class="line">        <span class="keyword">int</span> m_2l = m_2.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n_2.length()-m_2l;i++)&#123;</span><br><span class="line">            m_2 = <span class="string">&quot;0&quot;</span> + m_2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n_2.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m_2[i] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; n_2[i] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(n-m &lt; <span class="built_in">pow</span>(<span class="number">2</span>,n_2.length()-i<span class="number">-1</span>)) ans.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span> ans.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ans.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans_int = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[i] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                ans_int += <span class="built_in">pow</span>(<span class="number">2</span>,ans.length()-i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans_int;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">biTrans</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">int</span> num = (<span class="keyword">int</span>)log2(x);</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="built_in">pow</span>(<span class="number">2</span>,num))&#123;</span><br><span class="line">                x = x - <span class="built_in">pow</span>(<span class="number">2</span>,num);</span><br><span class="line">                str.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">                        str.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">                        num--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                str.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            num -- ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>执行用时 :36 ms, 在所有 C++ 提交中击败了21.63%的用户</p>
<p>内存消耗 :8.6 MB, 在所有 C++ 提交中击败了5.30%的用户</p>
<p>从第二点出发可以直接在二进制数上操作，即结果为端点两数从高位开始取连续的相同部分；一旦某一位开始不同，其后取交必为0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; m != n; ++offset) &#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n &lt;&lt; offset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :24 ms, 在所有 C++ 提交中击败了56.06%的用户</p>
<p>内存消耗 :8 MB, 在所有 C++ 提交中击败了70.45%的用户</p>
</blockquote>
<hr>
<h3 id="242-Easy-有效的字母异位词-Valid-Anagram"><a href="#242-Easy-有效的字母异位词-Valid-Anagram" class="headerlink" title="#242 [Easy]有效的字母异位词 Valid Anagram"></a>#242 [Easy]有效的字母异位词 <a href="https://leetcode-cn.com/problems/valid-anagram/">Valid Anagram</a></h3><blockquote>
<p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p>
</blockquote>
<p>注意审题，字母异位词的意思是相同的字母打乱生成的串(原题没有明确定义，有些坑)。</p>
<p>第一个想到的是存字典(C++ map)，这种做法可以处理非unicode字符，但是有一个 $O(n)$ 的空间花销（对于不确定的字符种类数来说，若视字符种类数为确定数量的话为 $O(1)$ ）。我后面才看到纯小写字母的字符串，可以直接排序后逐项判断，不过时间就不是 $O(n)$ 的了。</p>
<p>第一次用map，这里的int型初始值都是0，和python的dict有点不一样(因为dict不知道你的值的类型)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; s_map, t_map;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> l = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">            s_map[s[i]]++;</span><br><span class="line">            t_map[t[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s_map[s[i]] != t_map[s[i]]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实可以不用两个map，s在map上++而t在map上—即可，最终判断map是否全零。</p>
<blockquote>
<p>执行用时 :28 ms, 在所有 C++ 提交中击败了40.59%的用户</p>
<p>内存消耗 :9.7 MB, 在所有 C++ 提交中击败了5.14%的用户</p>
</blockquote>
<hr>
<h3 id="107-Easy-二叉树的层次遍历II-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Easy-二叉树的层次遍历II-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="#107 [Easy] 二叉树的层次遍历II Binary Tree Level Order Traversal II"></a>#107 [Easy] 二叉树的层次遍历II <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">Binary Tree Level Order Traversal II</a></h3><blockquote>
<p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
</blockquote>
<p>遍历树，递归大法好。第一次用STL中的 <code>reverse</code>  函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        iteration(root, ans, <span class="number">0</span>);</span><br><span class="line">        reverse(ans.begin(),ans.end());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">iteration</span><span class="params">(TreeNode *root, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;<span class="built_in">array</span>, <span class="keyword">int</span> layer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.size() &lt;= layer) <span class="built_in">array</span>.push_back(&#123;&#125;);</span><br><span class="line">        <span class="built_in">array</span>[layer].push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left  != <span class="literal">NULL</span>) iteration(root-&gt;left,  <span class="built_in">array</span>, layer+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span>) iteration(root-&gt;right, <span class="built_in">array</span>, layer+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :4 ms, 在所有 C++ 提交中击败了97.54%的用户</p>
<p>内存消耗 :14.7 MB, 在所有 C++ 提交中击败了23.82%的用户</p>
</blockquote>
<hr>
<h3 id="61-Medium-旋转链表-Rotate-List"><a href="#61-Medium-旋转链表-Rotate-List" class="headerlink" title="#61 [Medium] 旋转链表 Rotate List"></a>#61 [Medium] 旋转链表 <a href="https://leetcode-cn.com/problems/rotate-list/">Rotate List</a></h3><blockquote>
<p>给定一个链表，旋转链表，将链表每个节点向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p>
</blockquote>
<p>只要找到需要移位的链表段，把头尾的next指针改一下即可。怎么找到需要移位的链表段思路简单但是也需要考虑一些特殊情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *fast, *slow, *ans;</span><br><span class="line">        fast = head, slow = head;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">1</span>; <span class="comment">//记录长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            l++;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next == <span class="literal">NULL</span>) &#123; </span><br><span class="line">                fast = head; </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k%l;i++)&#123; <span class="comment">//k特别大时去掉循环</span></span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span>)&#123; </span><br><span class="line">          <span class="comment">//fast指向改动段尾部节点，slow指向不动段尾部节点</span></span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast == slow) <span class="keyword">return</span> head;</span><br><span class="line">        ans = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        fast-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :12 ms, 在所有 C++ 提交中击败了86.03%的用户</p>
<p>内存消耗 :8.9 MB, 在所有 C++ 提交中击败了88.27%的用户</p>
</blockquote>
<hr>
<h3 id="1109-Medium-航班预订统计-Corporate-Flight-Bookings"><a href="#1109-Medium-航班预订统计-Corporate-Flight-Bookings" class="headerlink" title="#1109 [Medium] 航班预订统计 Corporate Flight Bookings"></a>#1109 [Medium] 航班预订统计 <a href="https://leetcode-cn.com/problems/corporate-flight-bookings/">Corporate Flight Bookings</a></h3><blockquote>
<p>这里有 n 个航班，它们分别从 1 到 n 进行编号。</p>
<p>我们这儿有一份航班预订表，表中第 i 条预订记录 bookings[i] = [i, j, k] 意味着我们在从 i 到 j 的每个航班上预订了 k 个座位。</p>
<p>请你返回一个长度为 n 的数组 answer，按航班编号顺序返回每个航班上预订的座位数。</p>
<p>1 &lt;= bookings.length &lt;= 20000<br>1 &lt;= bookings[i][0] &lt;= bookings[i][1] &lt;= n &lt;= 20000<br>1 &lt;= bookings[i][2] &lt;= 10000</p>
</blockquote>
<p>这道题主要的难点是卡时间，不能直接进行模拟，一些测试点还锁死了合并处理的可能。这题必须进行预处理，把多个bookings的数据格式整理成长度为n记录bookings起始点和终点的格式，便于后面计算的时候遍历。预处理和计算的复杂度都是 $O(n)$ 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; start, end, ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            start.push_back(<span class="number">0</span>);</span><br><span class="line">            end.push_back(<span class="number">0</span>);</span><br><span class="line">            ans.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bookings.size();i++)&#123;</span><br><span class="line">            start[bookings[i][<span class="number">0</span>]<span class="number">-1</span>] += bookings[i][<span class="number">2</span>];</span><br><span class="line">            end[bookings[i][<span class="number">1</span>]<span class="number">-1</span>] += bookings[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">0</span>] = start[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            ans[i] = ans[i<span class="number">-1</span>] + start[i] - end[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :364 ms, 在所有 C++ 提交中击败了66.94%的用户</p>
<p>内存消耗 :46.5 MB, 在所有 C++ 提交中击败了100.00%的用户</p>
</blockquote>
<hr>
<h3 id="240-Medium-搜索二维矩阵II-Search-a-2D-Matrix-II"><a href="#240-Medium-搜索二维矩阵II-Search-a-2D-Matrix-II" class="headerlink" title="#240 [Medium] 搜索二维矩阵II Search a 2D Matrix II"></a>#240 [Medium] 搜索二维矩阵II <a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">Search a 2D Matrix II</a></h3><blockquote>
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p>
<p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。</p>
</blockquote>
<p>一个比较慢的算法时逐行搜索，跳过从最左边元素大于target、最右边元素小于target的行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> line=<span class="number">0</span>;line&lt;matrix.size();line++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[line].size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[line][<span class="number">0</span>] &gt; target || matrix[line][matrix[line].size()<span class="number">-1</span>] &lt; target) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;matrix[line].size();col++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[line][col] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(matrix[line][col] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :600 ms, 在所有 C++ 提交中击败了9.53%的用户</p>
<p>内存消耗 :12.7 MB, 在所有 C++ 提交中击败了91.83%的用户</p>
</blockquote>
<p>可以递归地四分这个矩阵，可以通过同样的规则排除掉至少一个分块矩阵。</p>
<hr>
<h3 id="906-Hard-超级回文数-Super-Palindromes"><a href="#906-Hard-超级回文数-Super-Palindromes" class="headerlink" title="#906 [Hard] 超级回文数 Super Palindromes"></a>#906 [Hard] 超级回文数 <a href="https://leetcode-cn.com/problems/super-palindromes/">Super Palindromes</a></h3><blockquote>
<p>如果一个正整数自身是回文数，而且它也是一个回文数的平方，那么我们称这个数为超级回文数。</p>
<p>现在，给定两个正整数 L 和 R （以字符串形式表示），返回包含在范围 [L, R] 中的超级回文数的数目。</p>
<p>提示：</p>
<p>1 &lt;= len(L) &lt;= 18<br>1 &lt;= len(R) &lt;= 18<br>L 和 R 是表示 [1, 10^18) 范围的整数的字符串。<br>int(L) &lt;= int(R)</p>
</blockquote>
<p>由于L、R在long型的表示范围内，且这个范围内的回文数并不多(70个左右)，大部分答案是自己打表过的(所以平均时间很快)。官方标答为对 $[1,10^5]$ 区间遍历生成回文数，判断其平方是否为区间内超级回文数。</p>
<p>实际这样操作耗时过大，可以进一步优化。考虑回文数的竖式乘法，由于回文数的乘方必须得是回文数，而乘法操作中的进位总是破坏回文对称性，所以回文数的乘法中一定不能进位。最容易进位的位置总是结果中的中间位(也是乘数中的顶位)，通过计算可以知道对于一个 $n$ 回文数，其乘方如果不在顶位上进位，一定有  $\sum n[i]^2 &lt; 10$ 。更进一步的可以找到更多规律，比如除了9之外，剩余的超级回文数开方的数总是由0、1和2组成 (因为 $1^2+3^2+1^2&gt;10$) ，且由于平方和不能超过10，除0之外的数只能有几种组合(11、121、1111、22等)，使用这几种组合可以通过组合数用很少的运算量在任意位数上直接生成该位数的所有超级回文数。虽然仍然需要特殊讨论的情况(奇偶数，9等)，但是肯定比打表更普适，也比官方标答快（因为是直接生成超级回文数而非遍历）。</p>
<p>下面的代码只用上面的部分规则对遍历进行了优化，实质还是遍历区间，所以还是比较慢。如果用3进制来优化遍历，不仅极大优化遍历效果，写起来也容易。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superpalindromesInRange</span><span class="params">(<span class="built_in">string</span> L, <span class="built_in">string</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对于3位aba回文数，a^2+b^2+a^2 &lt; 10 （不进位）</span></span><br><span class="line">        <span class="comment">//对于n位abcd...ff...dcba，2a^2+2b^2+...+2f^2 &lt; 10，前半部分&lt;6</span></span><br><span class="line">        <span class="comment">// 1 2 3/ 11 22 111 121 1111 1111.... 1(x10)</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> i_s = to_string(i);</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i_s.length();j++)</span><br><span class="line">                sum += <span class="built_in">pow</span>(i_s[j]<span class="number">-48</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(sum != <span class="number">9</span> &amp;&amp; sum &gt; <span class="number">6</span> ) <span class="keyword">continue</span>;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">string</span> ii = to_string(i); <span class="comment">//偶数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i_s.length()<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">                ii += i_s[j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ii.length();j++)</span><br><span class="line">                sum += <span class="built_in">pow</span>(ii[j]<span class="number">-48</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; <span class="number">10</span>)&#123;</span><br><span class="line">                num = <span class="built_in">pow</span>(stol(ii),<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= stol(R) &amp;&amp; num &gt;= stol(L))</span><br><span class="line">                    ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">string</span> iii = to_string(i); <span class="comment">//奇数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i_s.length()<span class="number">-2</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">                iii += i_s[j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;iii.length();j++)</span><br><span class="line">                sum += <span class="built_in">pow</span>(iii[j]<span class="number">-48</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= <span class="number">10</span>) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            num = <span class="built_in">pow</span>(stol(iii),<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(num &lt;= stol(R) &amp;&amp; num &gt;= stol(L))</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :1164 ms, 在所有 C++ 提交中击败了16.67%的用户</p>
<p>内存消耗 :8.6 MB, 在所有 C++ 提交中击败了96.00%的用户</p>
</blockquote>
<hr>
<h3 id="942-Easy-增减字符串匹配-DI-String-Match"><a href="#942-Easy-增减字符串匹配-DI-String-Match" class="headerlink" title="#942 [Easy] 增减字符串匹配 DI String Match"></a>#942 [Easy] 增减字符串匹配 <a href="https://leetcode-cn.com/problems/di-string-match/">DI String Match</a></h3><blockquote>
<p>给定只含 “I”（增大）或 “D”（减小）的字符串 S ，令 N = S.length。</p>
<p>返回 [0, 1, …, N] 的任意排列 A 使得对于所有 i = 0, …, N-1，都有：</p>
<p>如果 S[i] == “I”，那么 A[i] &lt; A[i+1]<br>如果 S[i] == “D”，那么 A[i] &gt; A[i+1]</p>
</blockquote>
<p>注意审题，返回的是区间内的排列，即不可有重复数字。</p>
<p>直接在递增数列上对D进行处理即可。对连续的n个D，彻底逆序相应位置上的n+1个数（12345变54321）。这样可以既可以保证逆序区间内一定递减，又可以保证区间之间绝对的递增关系。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diStringMatch</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=S.length();i++) ans.push_back(i);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i] == <span class="string">&#x27;I&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(S[i] == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(i==S.length()<span class="number">-1</span> || S[i+<span class="number">1</span>] == <span class="string">&#x27;I&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> len = count;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=len;j++)&#123;</span><br><span class="line">                        ans[i+<span class="number">1</span>-j] -= count;</span><br><span class="line">                        count -= <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :56 ms, 在所有 C++ 提交中击败了92.67%的用户</p>
<p>内存消耗 :10.5 MB, 在所有 C++ 提交中击败了70.98%的用户</p>
</blockquote>
<hr>
<h3 id="885-Easy-螺旋矩阵III-Spiral-Matrix-III"><a href="#885-Easy-螺旋矩阵III-Spiral-Matrix-III" class="headerlink" title="#885 [Easy] 螺旋矩阵III Spiral Matrix III"></a>#885 [Easy] 螺旋矩阵III <a href="https://leetcode-cn.com/problems/spiral-matrix-iii/">Spiral Matrix III</a></h3><blockquote>
<p>在 R 行 C 列的矩阵上，我们从 (r0, c0) 面朝东面开始</p>
<p>这里，网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。</p>
<p>现在，我们以顺时针按螺旋状行走，访问此网格中的每个位置。</p>
<p>每当我们移动到网格的边界之外时，我们会继续在网格之外行走（但稍后可能会返回到网格边界）。</p>
<p>最终，我们到过网格的所有 R * C 个空间。</p>
<p>按照访问顺序返回表示网格位置的坐标列表。</p>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= R &lt;= 100</code></li>
<li><code>1 &lt;= C &lt;= 100</code></li>
<li><code>0 &lt;= r0 &lt; R</code></li>
<li><code>0 &lt;= c0 &lt; C</code></li>
</ol>
</blockquote>
<p>看数据规模，直接模拟行走就能过，走的时候判断一下该点是否需要输出即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; spiralMatrixIII(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; point;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>, step = <span class="number">0</span>, dir, r = r0, c = c0;</span><br><span class="line">        <span class="keyword">while</span>(ans.size() &lt; R*C)&#123;</span><br><span class="line">            dir = step%<span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span>(dir == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                    point = &#123;r, c+i&#125;;</span><br><span class="line">                    <span class="keyword">if</span>(isInMat(r,c+i,R,C))</span><br><span class="line">                      ans.push_back(point);</span><br><span class="line">                &#125;</span><br><span class="line">                c += len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dir == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                    point = &#123;r+i, c&#125;;</span><br><span class="line">                    <span class="keyword">if</span>(isInMat(r+i,c,R,C)) </span><br><span class="line">                    	ans.push_back(point);</span><br><span class="line">                &#125;</span><br><span class="line">                r += len;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dir == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                    point = &#123;r, c-i&#125;;</span><br><span class="line">                    <span class="keyword">if</span>(isInMat(r,c-i,R,C))</span><br><span class="line">                      ans.push_back(point);</span><br><span class="line">                &#125;</span><br><span class="line">                c -= len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dir == <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                    point = &#123;r-i, c&#125;;</span><br><span class="line">                    <span class="keyword">if</span>(isInMat(r-i,c,R,C)) </span><br><span class="line">                      ans.push_back(point);</span><br><span class="line">                &#125;</span><br><span class="line">                r -= len;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInMat</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> R, <span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r &gt;= <span class="number">0</span> &amp;&amp; r &lt;= R<span class="number">-1</span> &amp;&amp; c &gt;=<span class="number">0</span> &amp;&amp; c &lt;= C<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :164 ms, 在所有 C++ 提交中击败了7.50%的用户</p>
<p>内存消耗 :13.5 MB, 在所有 C++ 提交中击败了84.38%的用户</p>
</blockquote>
<hr>
<h3 id="207-Medium-课程表-Course-Schedule"><a href="#207-Medium-课程表-Course-Schedule" class="headerlink" title="#207 [Medium] 课程表 Course Schedule"></a>#207 [Medium] 课程表 <a href="https://leetcode-cn.com/problems/course-schedule/">Course Schedule</a></h3><blockquote>
<p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p>
<p>示例 1:</p>
<p>输入: 2, [[1,0]]<br>输出: true<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</p>
<p>示例 2:</p>
<p>输入: 2, [[1,0],[0,1]]<br>输出: false<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</p>
<p>说明:</p>
<p>输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。<br>你可以假定输入的先决条件中没有重复的边。</p>
<p>提示:</p>
<p>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。<br>拓扑排序也可以通过 BFS 完成。</p>
</blockquote>
<p>之前一直随机做题。。这次定向搞一道图论复习一下。</p>
<p>说明和提示里说的很清楚了，问题等价于查一个有向图中是否有环。DFS或者BFS都可以。程序和标答差不太多，主要是我习惯用自定义的节点数据结构，其实用数组做邻接表也完全可以解决。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// build the graph</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;Node*&gt; classes;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            Node *node = <span class="keyword">new</span> Node();</span><br><span class="line">            node-&gt;val = i;</span><br><span class="line">            classes.push_back(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.size();i++)&#123;</span><br><span class="line">            classes[prerequisites[i][<span class="number">0</span>]]-&gt;sub_array.push_back(classes[prerequisites[i][<span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// done</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dfs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(classes[i]-&gt;islearn == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(classes[i]-&gt;islearn == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            search(numCourses, classes[i]);</span><br><span class="line">            <span class="keyword">if</span>(classes[i]-&gt;islearn == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> islearn = <span class="number">2</span>; <span class="comment">// 2 for undefined</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;Node*&gt; sub_array;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> numCourses, Node* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;sub_array.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            node-&gt;islearn = <span class="number">1</span>; <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;islearn = <span class="number">3</span>; <span class="comment">// 3 for searching</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;node-&gt;sub_array.size();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;sub_array[i]-&gt;islearn == <span class="number">2</span>)&#123;</span><br><span class="line">                search(numCourses, node-&gt;sub_array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;sub_array[i]-&gt;islearn == <span class="number">3</span> || node-&gt;sub_array[i]-&gt;islearn == <span class="number">0</span>)&#123;</span><br><span class="line">                    node-&gt;islearn = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;islearn = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :52 ms, 在所有 C++ 提交中击败了37.92%的用户</p>
<p>内存消耗 :13.4 MB, 在所有 C++ 提交中击败了16.84%的用户</p>
</blockquote>
<hr>
<h3 id="200-Medium-岛屿数量-Number-of-Islands"><a href="#200-Medium-岛屿数量-Number-of-Islands" class="headerlink" title="#200 [Medium] 岛屿数量 Number of Islands"></a>#200 [Medium] 岛屿数量 <a href="https://leetcode-cn.com/problems/number-of-islands/">Number of Islands</a></h3><blockquote>
<p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
</blockquote>
<p>说来惭愧，第一次学并查集，第一次写并查集的程序。写的时候觉得DFS虽然复杂度等级一样，但是在这里应该会很慢，但实际跑了 一下DFS似乎也不慢，时间空间都好过并查集，只能说感性上的估计还是不靠谱，有时候硬写DFS也不是不行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node*&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Node*&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.size();i++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;Node*&gt; newVec;</span><br><span class="line">            <span class="built_in">map</span>.push_back(newVec);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[i].size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    Node* newNode = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">map</span>[i].push_back(newNode);</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;=<span class="number">1</span> &amp;&amp; <span class="built_in">map</span>[i<span class="number">-1</span>][j]-&gt;val == <span class="number">1</span>) <span class="built_in">map</span>[i][j]-&gt;pre = <span class="built_in">map</span>[i<span class="number">-1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=<span class="number">1</span> &amp;&amp; <span class="built_in">map</span>[i][j<span class="number">-1</span>]-&gt;val == <span class="number">1</span>) <span class="built_in">map</span>[i][j]-&gt;pre = <span class="built_in">map</span>[i][j<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;=<span class="number">1</span> &amp;&amp; j&gt;= <span class="number">1</span> &amp;&amp; <span class="built_in">map</span>[i<span class="number">-1</span>][j]-&gt;val == <span class="number">1</span> &amp;&amp; <span class="built_in">map</span>[i][j<span class="number">-1</span>]-&gt;val == <span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(Node::search(<span class="built_in">map</span>[i<span class="number">-1</span>][j]) != Node::search(<span class="built_in">map</span>[i][j<span class="number">-1</span>]))</span><br><span class="line">                            Node::search(<span class="built_in">map</span>[i][j<span class="number">-1</span>])-&gt;pre = Node::search(<span class="built_in">map</span>[i<span class="number">-1</span>][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]-&gt;pre == <span class="literal">NULL</span>) <span class="built_in">set</span>.push_back(<span class="built_in">map</span>[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    Node *newNode = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">map</span>[i].push_back(newNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">set</span>.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">set</span>.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>[i]-&gt;pre != <span class="literal">NULL</span>) ans--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Node(<span class="keyword">int</span> val)&#123; <span class="keyword">this</span>-&gt;val = val; &#125;;</span><br><span class="line">        Node *pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> Node* <span class="title">search</span><span class="params">(Node *node)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;pre == <span class="literal">NULL</span>) <span class="keyword">return</span> node;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> search(node-&gt;pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nodeUnion</span><span class="params">(Node *a, Node *b)</span></span>&#123;</span><br><span class="line">            Node::search(a)-&gt;pre = Node::search(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :40 ms, 在所有 C++ 提交中击败了5.71%的用户</p>
<p>内存消耗 :14.4 MB, 在所有 C++ 提交中击败了5.04%的用户</p>
</blockquote>
<hr>
<h3 id="746-Easy-使用最小花费爬楼梯-Min-Cost-Climbing-Stairs"><a href="#746-Easy-使用最小花费爬楼梯-Min-Cost-Climbing-Stairs" class="headerlink" title="#746 [Easy] 使用最小花费爬楼梯 Min Cost Climbing Stairs"></a>#746 [Easy] 使用最小花费爬楼梯 <a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">Min Cost Climbing Stairs</a></h3><blockquote>
<p>数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p>
<p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p>
</blockquote>
<p>做一道Medium的DP题练手，突然发现自己好像不会DP了，赶紧来一道Easy的DP压压惊。。</p>
<p>最优子问题是求上到第i级台阶的最小总花费，求解需要知道当前第i级台阶单级花费和第i-2/i-1级的最小总花费。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(cost.size())</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(cost.size() == <span class="number">2</span>) <span class="keyword">return</span> min(cost[<span class="number">0</span>], cost[<span class="number">1</span>]);</span><br><span class="line">        ans[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        ans[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;cost.size();i++)&#123;</span><br><span class="line">            ans[i] = min(ans[i<span class="number">-1</span>] + cost[i], ans[i<span class="number">-2</span>] + cost[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(ans[cost.size()<span class="number">-1</span>], ans[cost.size()<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :4 ms, 在所有 C++ 提交中击败了98.79%的用户</p>
<p>内存消耗 :8.8 MB, 在所有 C++ 提交中击败了78.30%的用户</p>
</blockquote>
<hr>
<h3 id="768-Easy-托普利茨矩阵-Toeplitz-Matrix"><a href="#768-Easy-托普利茨矩阵-Toeplitz-Matrix" class="headerlink" title="#768 [Easy] 托普利茨矩阵 Toeplitz Matrix"></a>#768 [Easy] 托普利茨矩阵 <a href="https://leetcode-cn.com/problems/toeplitz-matrix/">Toeplitz Matrix</a></h3><blockquote>
<p>如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵。</p>
<p>给定一个 M x N 的矩阵，当且仅当它是托普利茨矩阵时返回 True。</p>
</blockquote>
<p>简单的检索。Hard不会做，只能写写Easy维持生活这样子。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isToeplitzMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = matrix.size(), y = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = matrix[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;y &amp;&amp; i+j&lt;x;j++)</span><br><span class="line">                <span class="keyword">if</span>(matrix[i+j][j] != num)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;y;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = matrix[<span class="number">0</span>][i];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;x &amp;&amp; i+j&lt;y;j++)</span><br><span class="line">                        <span class="keyword">if</span>(matrix[j][i+j] != num)  <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :12 ms, 在所有 C++ 提交中击败了91.48%的用户</p>
<p>内存消耗 :9.7 MB, 在所有 C++ 提交中击败了83.67%的用户</p>
</blockquote>
<hr>
<h3 id="643-Easy-子数组最大平均数I-Maximum-Average-Subarray-I"><a href="#643-Easy-子数组最大平均数I-Maximum-Average-Subarray-I" class="headerlink" title="#643 [Easy] 子数组最大平均数I Maximum Average Subarray I"></a>#643 [Easy] 子数组最大平均数I <a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/">Maximum Average Subarray I</a></h3><blockquote>
<p>给定 <code>n</code> 个整数，找出平均数最大且长度为 <code>k</code> 的连续子数组，并输出该最大平均数。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++) ans += nums[i];</span><br><span class="line">        sum = ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;nums.size();i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            sum -= nums[i-k];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; ans) ans = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans / k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>就是很简单的做法，然后我看其他人的代码的时候发现跑的快的几个都带了IO优化。。服辽</p>
<blockquote>
<p>执行用时 :188 ms, 在所有 C++ 提交中击败了44.39%的用户</p>
<p>内存消耗 :16.9 MB, 在所有 C++ 提交中击败了62.93%的用户</p>
</blockquote>
<hr>
<h3 id="221-Medium-最大正方形-Maximal-Square"><a href="#221-Medium-最大正方形-Maximal-Square" class="headerlink" title="#221 [Medium] 最大正方形 Maximal Square"></a>#221 [Medium] 最大正方形 <a href="https://leetcode-cn.com/problems/maximal-square/">Maximal Square</a></h3><blockquote>
<p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
</blockquote>
<p>这题不卡时间，直接暴力也可以做。对于每个1，开始从边长1开始找更大的正方形，并记录下当前找到的最大边长。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> y = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;y;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> newAns = findSquare(matrix, i, j);</span><br><span class="line">                <span class="keyword">if</span>(newAns &gt; ans) ans = newAns;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans*ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x+n &gt; matrix.size() || y+n &gt; matrix[<span class="number">0</span>].size()) <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;x+n &amp;&amp; i&lt;matrix.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][y+n<span class="number">-1</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> n<span class="number">-1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=y;i&lt;y+n &amp;&amp; i&lt;matrix[<span class="number">0</span>].size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[x+n<span class="number">-1</span>][i] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> n<span class="number">-1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :28 ms, 在所有 C++ 提交中击败了45.78%的用户</p>
<p>内存消耗 :10.3 MB, 在所有 C++ 提交中击败了100.00%的用户</p>
</blockquote>
<p>有一个比较独特的DP的方法，其实挺难想的， 用左-左上-上的数来递推当前格的数，即对每个1，将其更新为 $\min{\text{Left, Left-Up, Up}}+1$ ，并记录最大数。格子里数的意义是以当前格为右下顶点的正方形的最大边长。[但是这样子计数矩形，是行不通的]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(matrix[<span class="number">0</span>].size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();i++)&#123;</span><br><span class="line">            vec[i] = matrix[<span class="number">0</span>][i] - <span class="number">48</span>;</span><br><span class="line">            <span class="keyword">if</span>(vec[i] &gt; num) num = vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;matrix.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> pre_num = matrix[i<span class="number">-1</span>][<span class="number">0</span>] - <span class="number">48</span>;</span><br><span class="line">            vec[<span class="number">0</span>] = matrix[i][<span class="number">0</span>] - <span class="number">48</span>;</span><br><span class="line">            <span class="keyword">if</span>(vec[<span class="number">0</span>] &gt; num) num = vec[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;matrix[<span class="number">0</span>].size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid_num = vec[j];</span><br><span class="line">                    vec[j] = min(min(vec[j<span class="number">-1</span>], pre_num), vec[j]) + <span class="number">1</span>;</span><br><span class="line">                    pre_num = mid_num;</span><br><span class="line">                    <span class="keyword">if</span>(vec[j] &gt; num) num = vec[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">&#x27;0&#x27;</span>) vec[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num*num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :44 ms, 在所有 C++ 提交中击败了11.99%的用户</p>
<p>内存消耗 :10.6 MB, 在所有 C++ 提交中击败了96.41%的用户</p>
<p>（竟然还慢过暴力。。</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>习题</category>
        <category>OJ</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>OJ</tag>
        <tag>LeetCode</tag>
        <tag>习题</tag>
      </tags>
  </entry>
</search>
