<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="分享一些自己LeetCode题目的题解。 *标记的题目为待优化题目。">
<meta name="keywords" content="编程,OJ,LeetCode,习题">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode 题解记录(1)">
<meta property="og:url" content="http://yoursite.com/2019/08/05/OJ-LeetCode题解记录/index.html">
<meta property="og:site_name" content="Thiswinex&#39;s Blog">
<meta property="og:description" content="分享一些自己LeetCode题目的题解。 *标记的题目为待优化题目。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-07-27T12:30:59.405Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode 题解记录(1)">
<meta name="twitter:description" content="分享一些自己LeetCode题目的题解。 *标记的题目为待优化题目。">

<link rel="canonical" href="http://yoursite.com/2019/08/05/OJ-LeetCode题解记录/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>LeetCode 题解记录(1) | Thiswinex's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Thiswinex's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/05/OJ-LeetCode题解记录/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Thiswinex's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode 题解记录(1)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-08-05 15:25:52" itemprop="dateCreated datePublished" datetime="2019-08-05T15:25:52+08:00">2019-08-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/习题/" itemprop="url" rel="index"><span itemprop="name">习题</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/习题/OJ/" itemprop="url" rel="index"><span itemprop="name">OJ</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/习题/OJ/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>分享一些自己LeetCode题目的题解。</p>
<p>*标记的题目为待优化题目。</p>
<a id="more"></a>
<h3 id="799-Medium-香槟塔-Champagne-Tower"><a href="#799-Medium-香槟塔-Champagne-Tower" class="headerlink" title="#799 [Medium]香槟塔 Champagne Tower"></a>#799 [Medium]香槟塔 <a href="https://leetcode-cn.com/problems/champagne-tower/" target="_blank" rel="noopener">Champagne Tower</a></h3><blockquote>
<p>我们把玻璃杯摆成金字塔的形状，其中第一层有1个玻璃杯，第二层有2个，依次类推到第100层，每个玻璃杯(250ml)将盛有香槟。</p>
<p>从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）</p>
<p>例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟。</p>
<p>现在当倾倒了非负整数杯香槟后，返回第 i 行 j 个玻璃杯所盛放的香槟占玻璃杯容积的比例（i 和 j都从0开始）。</p>
</blockquote>
<p>香槟的数量范围很大，所以不要想一杯一杯的模拟倾倒。很容易想到香槟的倾倒类似于杨辉三角，但是由于杯子最大容量为1，满了就会溢出，所以也不完全类似。一个简单的方案是对杯子遍历，先把杨辉三角存入杯子数组中，然后把溢出来的部分平均分给下面的杯子。这样从上到下遍历一遍就能得到正确的答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">champagneTower</span><span class="params">(<span class="keyword">int</span> poured, <span class="keyword">int</span> query_row, <span class="keyword">int</span> query_glass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fully_layer = <span class="built_in">floor</span>(log2(poured+<span class="number">1</span>))<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> rest_poured = poured - (<span class="built_in">pow</span>(<span class="number">2</span>, fully_layer+<span class="number">1</span>)<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">double</span> glass[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">memset</span>(glass, <span class="number">0</span>, <span class="keyword">sizeof</span>(glass));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=fully_layer;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                glass[i][j] += ComNum(i, j);</span><br><span class="line">                glass[i+<span class="number">1</span>][j] += (glass[i][j]<span class="number">-1</span>)/<span class="number">2.0</span>;</span><br><span class="line">                glass[i+<span class="number">1</span>][j+<span class="number">1</span>] += (glass[i][j]<span class="number">-1</span>)/<span class="number">2.0</span>;</span><br><span class="line">                glass[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=fully_layer+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">double</span> frac = rest_poured / (<span class="built_in">pow</span>(<span class="number">2</span>, fully_layer+<span class="number">1</span>));</span><br><span class="line">            glass[fully_layer+<span class="number">1</span>][j] += ComNum(fully_layer+<span class="number">1</span>, j)*frac;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(glass[fully_layer+<span class="number">1</span>][j] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                glass[fully_layer+<span class="number">2</span>][j] += (glass[fully_layer+<span class="number">1</span>][j]<span class="number">-1</span>)/<span class="number">2.0</span>;</span><br><span class="line">                glass[fully_layer+<span class="number">2</span>][j+<span class="number">1</span>] += (glass[fully_layer+<span class="number">1</span>][j]<span class="number">-1</span>)/<span class="number">2.0</span>;</span><br><span class="line">                glass[fully_layer+<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=fully_layer+<span class="number">2</span>;i&lt;query_row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(glass[i][j] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    glass[i+<span class="number">1</span>][j] += (glass[i][j]<span class="number">-1</span>)/<span class="number">2.0</span>;</span><br><span class="line">                    glass[i+<span class="number">1</span>][j+<span class="number">1</span>] += (glass[i][j]<span class="number">-1</span>)/<span class="number">2.0</span>;</span><br><span class="line">                    glass[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> ans = glass[query_row][query_glass];</span><br><span class="line">        <span class="keyword">if</span>(ans &gt; <span class="number">1</span>) ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">ComNum</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> numerator = <span class="number">1.0</span>, denominator = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            denominator *= (i+<span class="number">1</span>);</span><br><span class="line">            numerator *= (n-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numerator/denominator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :8 ms, 在所有 C++ 提交中击败了98.15%的用户</p>
<p>内存消耗 :8.8 MB, 在所有 C++ 提交中击败了84.62%的用户</p>
</blockquote>
<hr>
<h3 id="235-Easy-二叉搜索树的最近公共祖先-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Easy-二叉搜索树的最近公共祖先-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="#235 [Easy]二叉搜索树的最近公共祖先 Lowest Common Ancestor of a Binary Search Tree"></a>#235 [Easy]二叉搜索树的最近公共祖先<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener"> Lowest Common Ancestor of a Binary Search Tree</a></h3><blockquote>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
</blockquote>
<p>直接用二叉搜索树的性质就行了，这个公共祖先的值必然在两个节点的值之间，递归求解即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *ans;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val)&#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">            ans = lowestCommonAncestor(root, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val)&#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">            ans = lowestCommonAncestor(root, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ans = root;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :84 ms, 在所有 C++ 提交中击败了9.13%的用户</p>
<p>内存消耗 :25.8 MB, 在所有 C++ 提交中击败了49.37%的用户</p>
</blockquote>
<hr>
<h3 id="236-Medium-二叉树的最近公共祖先-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Medium-二叉树的最近公共祖先-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="#236 [Medium]二叉树的最近公共祖先 Lowest Common Ancestor of a Binary Tree"></a>#236 [Medium]二叉树的最近公共祖先 <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">Lowest Common Ancestor of a Binary Tree</a></h3><blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
</blockquote>
<p>用栈存储两个节点的到根节点的序列，序列通过递归求得。最后比较序列即可。一个笨方法。</p>
<p>看了一下其他人分享的题解，也有重建树创建父节点的，DFS的，加布尔标记的，感觉也都不是很聪明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; sp, sq;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        findParent(root, p, sp); <span class="built_in">cout</span>&lt;&lt;<span class="string">"---"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        findParent(root, q, sq);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;sp.size()&lt;&lt;<span class="string">" "</span>&lt;&lt;sq.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; *max, *min;</span><br><span class="line">        TreeNode *ans = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(sp.size() &gt; sq.size()) &#123; max = &amp;sp; min = &amp;sq; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; max = &amp;sq; min = &amp;sp; &#125;</span><br><span class="line">        <span class="keyword">int</span> i, max_size = max-&gt;size(), min_size = min-&gt;size();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;(max_size-min_size) &amp;&amp; ans == <span class="literal">NULL</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max-&gt;top() == min-&gt;top())&#123;</span><br><span class="line">                ans = max-&gt;top();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> max-&gt;pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;max_size &amp;&amp; ans == <span class="literal">NULL</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max-&gt;top() == min-&gt;top())&#123;</span><br><span class="line">                ans = max-&gt;top();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; max-&gt;pop(); min-&gt;pop(); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findParent</span><span class="params">(TreeNode* root, TreeNode* node, <span class="built_in">stack</span>&lt;TreeNode*&gt; &amp;s)</span></span>&#123;</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Push "</span>&lt;&lt;root-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == node) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Pop "</span>&lt;&lt;s.top()-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">if</span>(findParent(root-&gt;left, node, s)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">if</span>(findParent(root-&gt;right, node, s)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Pop "</span>&lt;&lt;s.top()-&gt;val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :40 ms, 在所有 C++ 提交中击败了29.07%的用户</p>
<p>内存消耗 :20.5 MB, 在所有 C++ 提交中击败了6.90%的用户</p>
</blockquote>
<hr>
<h3 id="239-Hard-滑动窗口最大值-Sliding-Window-Maximum"><a href="#239-Hard-滑动窗口最大值-Sliding-Window-Maximum" class="headerlink" title="#239* [Hard]滑动窗口最大值 Sliding Window Maximum"></a>#239* [Hard]滑动窗口最大值 <a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">Sliding Window Maximum</a></h3><blockquote>
<p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p>示例:</p>
<p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]<br>解释: </p>
<p>  滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p>
</blockquote>
<p>$O(nk)$ 的算法非常简单，但是很慢：</p>
<p>执行用时 :156 ms, 在所有 C++ 提交中击败了10.90%的用户</p>
<p>内存消耗 :12.6 MB, 在所有 C++ 提交中击败了98.71%的用户</p>
<p>可以尝试 $O(n)$ 的算法，较为复杂。问题的关键在于在常数时间内处理滑动窗口内的最值。</p>
<hr>
<h3 id="404-Easy-左子叶之和-Sum-of-Left-Leaves"><a href="#404-Easy-左子叶之和-Sum-of-Left-Leaves" class="headerlink" title="#404 [Easy]左子叶之和 Sum of Left Leaves"></a>#404 [Easy]左子叶之和 <a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">Sum of Left Leaves</a></h3><blockquote>
<p>计算给定二叉树的所有左叶子之和。</p>
</blockquote>
<p>直接递归就好，注意左叶子的定义和特殊情况。这里单独讲一下这题是因为才发现LeetCode可以自定义测试用例，可以对一些需要单独讨论的情形进行测试来避免踩坑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span> || (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left_val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right_val = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">NULL</span>) </span><br><span class="line">            left_val = root-&gt;left-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span> &amp;&amp; (root-&gt;left-&gt;left != <span class="literal">NULL</span> || root-&gt;left-&gt;right != <span class="literal">NULL</span>))</span><br><span class="line">            left_val = sumOfLeftLeaves(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span> &amp;&amp; (root-&gt;right-&gt;left != <span class="literal">NULL</span> || root-&gt;right-&gt;right != <span class="literal">NULL</span>)) </span><br><span class="line">            right_val = sumOfLeftLeaves(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> left_val + right_val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :4 ms, 在所有 C++ 提交中击败了90.75%的用户</p>
<p>内存消耗 :13.3 MB, 在所有 C++ 提交中击败了96.55%的用户</p>
</blockquote>
<hr>
<h3 id="536-Medium-从字符串生成二叉树-Construct-Binary-Tree-from-String"><a href="#536-Medium-从字符串生成二叉树-Construct-Binary-Tree-from-String" class="headerlink" title="#536 [Medium]从字符串生成二叉树 Construct Binary Tree from String"></a>#536 [Medium]从字符串生成二叉树 <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-string/" target="_blank" rel="noopener">Construct Binary Tree from String</a></h3><blockquote>
<p>你需要从一个包括括号和整数的字符串构建一棵二叉树。</p>
<p>输入的字符串代表一棵二叉树。它包括整数和随后的0，1或2对括号。整数代表根的值，一对括号内表示同样结构的子树。</p>
<p>若存在左子结点，则从左子结点开始构建。</p>
</blockquote>
<p>这题只要注意几个点就好，一个是树深度和字符转数字都需要存储(一般用栈)，一个是回溯的判定条件。如果以括号来判定数字的终止，则需要对无括号的单节点树做单独判断。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">str2tree</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">""</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; tree;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">        <span class="keyword">bool</span> isPositive = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span> || s[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> times = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(num.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                        val += times * num.top();</span><br><span class="line">                        times *= <span class="number">10</span>;</span><br><span class="line">                        num.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!isPositive) val = -val;</span><br><span class="line">                    root-&gt;val = val;</span><br><span class="line">                    isPositive = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                        tree.push(root);</span><br><span class="line">                        root-&gt;left = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                        root = root-&gt;left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        tree.push(root);</span><br><span class="line">                        root-&gt;right = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                        root = root-&gt;right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">                    root = tree.top();</span><br><span class="line">                    tree.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">'-'</span>)&#123;</span><br><span class="line">                isPositive = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                num.push((<span class="keyword">int</span>)(s[i]<span class="number">-48</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(num.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> times = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(num.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                val += times * num.top();</span><br><span class="line">                times *= <span class="number">10</span>;</span><br><span class="line">                num.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!isPositive) val = -val;</span><br><span class="line">            root-&gt;val = val;</span><br><span class="line">            isPositive = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :44 ms, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>内存消耗 :21.9 MB, 在所有 C++ 提交中击败了100.00%的用户</p>
</blockquote>
<hr>
<h3 id="201-Medium-数字范围按位与-Bitwise-AND-of-Numbers-Range"><a href="#201-Medium-数字范围按位与-Bitwise-AND-of-Numbers-Range" class="headerlink" title="#201 [Medium]数字范围按位与 Bitwise AND of Numbers Range"></a>#201 [Medium]数字范围按位与 <a href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/" target="_blank" rel="noopener">Bitwise AND of Numbers Range</a></h3><blockquote>
<p>给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。</p>
</blockquote>
<p>首先弄清楚题意，是把区间内所有的数字做按位<strong>与</strong> 。实际上只需要处理区间端点即可，由于区间内所有数字在相应位上都是1，结果在这一位才是1，所以对于结果的每一位，这一位为1仅当：</p>
<ol>
<li>端点两数在此位为1</li>
<li>端点两数的差小于此位上对应的二进制数(否则区间内总有一个数在此位上为0)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> m_2, n_2, ans;</span><br><span class="line">        m_2 = biTrans(m);</span><br><span class="line">        n_2 = biTrans(n);</span><br><span class="line">        <span class="keyword">int</span> m_2l = m_2.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n_2.length()-m_2l;i++)&#123;</span><br><span class="line">            m_2 = <span class="string">"0"</span> + m_2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n_2.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m_2[i] == <span class="string">'1'</span> &amp;&amp; n_2[i] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(n-m &lt; <span class="built_in">pow</span>(<span class="number">2</span>,n_2.length()-i<span class="number">-1</span>)) ans.append(<span class="string">"1"</span>);</span><br><span class="line">                <span class="keyword">else</span> ans.append(<span class="string">"0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ans.append(<span class="string">"0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans_int = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[i] == <span class="string">'1'</span>)</span><br><span class="line">                ans_int += <span class="built_in">pow</span>(<span class="number">2</span>,ans.length()-i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans_int;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">biTrans</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">int</span> num = (<span class="keyword">int</span>)log2(x);</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="built_in">pow</span>(<span class="number">2</span>,num))&#123;</span><br><span class="line">                x = x - <span class="built_in">pow</span>(<span class="number">2</span>,num);</span><br><span class="line">                str.append(<span class="string">"1"</span>);</span><br><span class="line">                <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">                        str.append(<span class="string">"0"</span>);</span><br><span class="line">                        num--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                str.append(<span class="string">"0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            num -- ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>执行用时 :36 ms, 在所有 C++ 提交中击败了21.63%的用户</p>
<p>内存消耗 :8.6 MB, 在所有 C++ 提交中击败了5.30%的用户</p>
<p>从第二点出发可以直接在二进制数上操作，即结果为端点两数从高位开始取连续的相同部分；一旦某一位开始不同，其后取交必为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; m != n; ++offset) &#123;</span><br><span class="line">            m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n &lt;&lt; offset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :24 ms, 在所有 C++ 提交中击败了56.06%的用户</p>
<p>内存消耗 :8 MB, 在所有 C++ 提交中击败了70.45%的用户</p>
</blockquote>
<hr>
<h3 id="242-Easy-有效的字母异位词-Valid-Anagram"><a href="#242-Easy-有效的字母异位词-Valid-Anagram" class="headerlink" title="#242 [Easy]有效的字母异位词 Valid Anagram"></a>#242 [Easy]有效的字母异位词 <a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">Valid Anagram</a></h3><blockquote>
<p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p>
</blockquote>
<p>注意审题，字母异位词的意思是相同的字母打乱生成的串(原题没有明确定义，有些坑)。</p>
<p>第一个想到的是存字典(C++ map)，这种做法可以处理非unicode字符，但是有一个 $O(n)$ 的空间花销（对于不确定的字符种类数来说，若视字符种类数为确定数量的话为 $O(1)$ ）。我后面才看到纯小写字母的字符串，可以直接排序后逐项判断，不过时间就不是 $O(n)$ 的了。</p>
<p>第一次用map，这里的int型初始值都是0，和python的dict有点不一样(因为dict不知道你的值的类型)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; s_map, t_map;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> l = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">            s_map[s[i]]++;</span><br><span class="line">            t_map[t[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s_map[s[i]] != t_map[s[i]]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实可以不用两个map，s在map上++而t在map上—即可，最终判断map是否全零。</p>
<blockquote>
<p>执行用时 :28 ms, 在所有 C++ 提交中击败了40.59%的用户</p>
<p>内存消耗 :9.7 MB, 在所有 C++ 提交中击败了5.14%的用户</p>
</blockquote>
<hr>
<h3 id="107-Easy-二叉树的层次遍历II-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Easy-二叉树的层次遍历II-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="#107 [Easy] 二叉树的层次遍历II Binary Tree Level Order Traversal II"></a>#107 [Easy] 二叉树的层次遍历II <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">Binary Tree Level Order Traversal II</a></h3><blockquote>
<p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
</blockquote>
<p>遍历树，递归大法好。第一次用STL中的 <code>reverse</code>  函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        iteration(root, ans, <span class="number">0</span>);</span><br><span class="line">        reverse(ans.begin(),ans.end());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">iteration</span><span class="params">(TreeNode *root, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;<span class="built_in">array</span>, <span class="keyword">int</span> layer)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.size() &lt;= layer) <span class="built_in">array</span>.push_back(&#123;&#125;);</span><br><span class="line">        <span class="built_in">array</span>[layer].push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left  != <span class="literal">NULL</span>) iteration(root-&gt;left,  <span class="built_in">array</span>, layer+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span>) iteration(root-&gt;right, <span class="built_in">array</span>, layer+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :4 ms, 在所有 C++ 提交中击败了97.54%的用户</p>
<p>内存消耗 :14.7 MB, 在所有 C++ 提交中击败了23.82%的用户</p>
</blockquote>
<hr>
<h3 id="61-Medium-旋转链表-Rotate-List"><a href="#61-Medium-旋转链表-Rotate-List" class="headerlink" title="#61 [Medium] 旋转链表 Rotate List"></a>#61 [Medium] 旋转链表 <a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">Rotate List</a></h3><blockquote>
<p>给定一个链表，旋转链表，将链表每个节点向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p>
</blockquote>
<p>只要找到需要移位的链表段，把头尾的next指针改一下即可。怎么找到需要移位的链表段思路简单但是也需要考虑一些特殊情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *fast, *slow, *ans;</span><br><span class="line">        fast = head, slow = head;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">1</span>; <span class="comment">//记录长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            l++;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next == <span class="literal">NULL</span>) &#123; </span><br><span class="line">                fast = head; </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k%l;i++)&#123; <span class="comment">//k特别大时去掉循环</span></span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span>)&#123; </span><br><span class="line">          <span class="comment">//fast指向改动段尾部节点，slow指向不动段尾部节点</span></span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast == slow) <span class="keyword">return</span> head;</span><br><span class="line">        ans = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        fast-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :12 ms, 在所有 C++ 提交中击败了86.03%的用户</p>
<p>内存消耗 :8.9 MB, 在所有 C++ 提交中击败了88.27%的用户</p>
</blockquote>
<hr>
<h3 id="1109-Medium-航班预订统计-Corporate-Flight-Bookings"><a href="#1109-Medium-航班预订统计-Corporate-Flight-Bookings" class="headerlink" title="#1109 [Medium] 航班预订统计 Corporate Flight Bookings"></a>#1109 [Medium] 航班预订统计 <a href="https://leetcode-cn.com/problems/corporate-flight-bookings/" target="_blank" rel="noopener">Corporate Flight Bookings</a></h3><blockquote>
<p>这里有 n 个航班，它们分别从 1 到 n 进行编号。</p>
<p>我们这儿有一份航班预订表，表中第 i 条预订记录 bookings[i] = [i, j, k] 意味着我们在从 i 到 j 的每个航班上预订了 k 个座位。</p>
<p>请你返回一个长度为 n 的数组 answer，按航班编号顺序返回每个航班上预订的座位数。</p>
<p>1 &lt;= bookings.length &lt;= 20000<br>1 &lt;= bookings[i][0] &lt;= bookings[i][1] &lt;= n &lt;= 20000<br>1 &lt;= bookings[i][2] &lt;= 10000</p>
</blockquote>
<p>这道题主要的难点是卡时间，不能直接进行模拟，一些测试点还锁死了合并处理的可能。这题必须进行预处理，把多个bookings的数据格式整理成长度为n记录bookings起始点和终点的格式，便于后面计算的时候遍历。预处理和计算的复杂度都是 $O(n)$ 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; corpFlightBookings(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; start, end, ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            start.push_back(<span class="number">0</span>);</span><br><span class="line">            end.push_back(<span class="number">0</span>);</span><br><span class="line">            ans.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bookings.size();i++)&#123;</span><br><span class="line">            start[bookings[i][<span class="number">0</span>]<span class="number">-1</span>] += bookings[i][<span class="number">2</span>];</span><br><span class="line">            end[bookings[i][<span class="number">1</span>]<span class="number">-1</span>] += bookings[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">0</span>] = start[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            ans[i] = ans[i<span class="number">-1</span>] + start[i] - end[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :364 ms, 在所有 C++ 提交中击败了66.94%的用户</p>
<p>内存消耗 :46.5 MB, 在所有 C++ 提交中击败了100.00%的用户</p>
</blockquote>
<hr>
<h3 id="240-Medium-搜索二维矩阵II-Search-a-2D-Matrix-II"><a href="#240-Medium-搜索二维矩阵II-Search-a-2D-Matrix-II" class="headerlink" title="#240 [Medium] 搜索二维矩阵II Search a 2D Matrix II"></a>#240 [Medium] 搜索二维矩阵II <a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">Search a 2D Matrix II</a></h3><blockquote>
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p>
<p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。</p>
</blockquote>
<p>一个比较慢的算法时逐行搜索，跳过从最左边元素大于target、最右边元素小于target的行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> line=<span class="number">0</span>;line&lt;matrix.size();line++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[line].size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[line][<span class="number">0</span>] &gt; target || matrix[line][matrix[line].size()<span class="number">-1</span>] &lt; target) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;matrix[line].size();col++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[line][col] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(matrix[line][col] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :600 ms, 在所有 C++ 提交中击败了9.53%的用户</p>
<p>内存消耗 :12.7 MB, 在所有 C++ 提交中击败了91.83%的用户</p>
</blockquote>
<p>可以递归地四分这个矩阵，可以通过同样的规则排除掉至少一个分块矩阵。</p>
<hr>
<h3 id="906-Hard-超级回文数-Super-Palindromes"><a href="#906-Hard-超级回文数-Super-Palindromes" class="headerlink" title="#906 [Hard] 超级回文数 Super Palindromes"></a>#906 [Hard] 超级回文数 <a href="https://leetcode-cn.com/problems/super-palindromes/" target="_blank" rel="noopener">Super Palindromes</a></h3><blockquote>
<p>如果一个正整数自身是回文数，而且它也是一个回文数的平方，那么我们称这个数为超级回文数。</p>
<p>现在，给定两个正整数 L 和 R （以字符串形式表示），返回包含在范围 [L, R] 中的超级回文数的数目。</p>
<p>提示：</p>
<p>1 &lt;= len(L) &lt;= 18<br>1 &lt;= len(R) &lt;= 18<br>L 和 R 是表示 [1, 10^18) 范围的整数的字符串。<br>int(L) &lt;= int(R)</p>
</blockquote>
<p>由于L、R在long型的表示范围内，且这个范围内的回文数并不多(70个左右)，大部分答案是自己打表过的(所以平均时间很快)。官方标答为对 $[1,10^5]$ 区间遍历生成回文数，判断其平方是否为区间内超级回文数。</p>
<p>实际这样操作耗时过大，可以进一步优化。考虑回文数的竖式乘法，由于回文数的乘方必须得是回文数，而乘法操作中的进位总是破坏回文对称性，所以回文数的乘法中一定不能进位。最容易进位的位置总是结果中的中间位(也是乘数中的顶位)，通过计算可以知道对于一个 $n$ 回文数，其乘方如果不在顶位上进位，一定有  $\sum n[i]^2 &lt; 10$ 。更进一步的可以找到更多规律，比如除了9之外，剩余的超级回文数开方的数总是由0、1和2组成 (因为 $1^2+3^2+1^2&gt;10$) ，且由于平方和不能超过10，除0之外的数只能有几种组合(11、121、1111、22等)，使用这几种组合可以通过组合数用很少的运算量在任意位数上直接生成该位数的所有超级回文数。虽然仍然需要特殊讨论的情况(奇偶数，9等)，但是肯定比打表更普适，也比官方标答快（因为是直接生成超级回文数而非遍历）。</p>
<p>下面的代码只用上面的部分规则对遍历进行了优化，实质还是遍历区间，所以还是比较慢。如果用3进制来优化遍历，不仅极大优化遍历效果，写起来也容易。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superpalindromesInRange</span><span class="params">(<span class="built_in">string</span> L, <span class="built_in">string</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对于3位aba回文数，a^2+b^2+a^2 &lt; 10 （不进位）</span></span><br><span class="line">        <span class="comment">//对于n位abcd...ff...dcba，2a^2+2b^2+...+2f^2 &lt; 10，前半部分&lt;6</span></span><br><span class="line">        <span class="comment">// 1 2 3/ 11 22 111 121 1111 1111.... 1(x10)</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> i_s = to_string(i);</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i_s.length();j++)</span><br><span class="line">                sum += <span class="built_in">pow</span>(i_s[j]<span class="number">-48</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(sum != <span class="number">9</span> &amp;&amp; sum &gt; <span class="number">6</span> ) <span class="keyword">continue</span>;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">string</span> ii = to_string(i); <span class="comment">//偶数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i_s.length()<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">                ii += i_s[j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ii.length();j++)</span><br><span class="line">                sum += <span class="built_in">pow</span>(ii[j]<span class="number">-48</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; <span class="number">10</span>)&#123;</span><br><span class="line">                num = <span class="built_in">pow</span>(stol(ii),<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= stol(R) &amp;&amp; num &gt;= stol(L))</span><br><span class="line">                    ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">string</span> iii = to_string(i); <span class="comment">//奇数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i_s.length()<span class="number">-2</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">                iii += i_s[j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;iii.length();j++)</span><br><span class="line">                sum += <span class="built_in">pow</span>(iii[j]<span class="number">-48</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= <span class="number">10</span>) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            num = <span class="built_in">pow</span>(stol(iii),<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(num &lt;= stol(R) &amp;&amp; num &gt;= stol(L))</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :1164 ms, 在所有 C++ 提交中击败了16.67%的用户</p>
<p>内存消耗 :8.6 MB, 在所有 C++ 提交中击败了96.00%的用户</p>
</blockquote>
<hr>
<h3 id="942-Easy-增减字符串匹配-DI-String-Match"><a href="#942-Easy-增减字符串匹配-DI-String-Match" class="headerlink" title="#942 [Easy] 增减字符串匹配 DI String Match"></a>#942 [Easy] 增减字符串匹配 <a href="https://leetcode-cn.com/problems/di-string-match/" target="_blank" rel="noopener">DI String Match</a></h3><blockquote>
<p>给定只含 “I”（增大）或 “D”（减小）的字符串 S ，令 N = S.length。</p>
<p>返回 [0, 1, …, N] 的任意排列 A 使得对于所有 i = 0, …, N-1，都有：</p>
<p>如果 S[i] == “I”，那么 A[i] &lt; A[i+1]<br>如果 S[i] == “D”，那么 A[i] &gt; A[i+1]</p>
</blockquote>
<p>注意审题，返回的是区间内的排列，即不可有重复数字。</p>
<p>直接在递增数列上对D进行处理即可。对连续的n个D，彻底逆序相应位置上的n+1个数（12345变54321）。这样可以既可以保证逆序区间内一定递减，又可以保证区间之间绝对的递增关系。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; diStringMatch(<span class="built_in">string</span> S) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=S.length();i++) ans.push_back(i);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i] == <span class="string">'I'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(S[i] == <span class="string">'D'</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(i==S.length()<span class="number">-1</span> || S[i+<span class="number">1</span>] == <span class="string">'I'</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> len = count;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=len;j++)&#123;</span><br><span class="line">                        ans[i+<span class="number">1</span>-j] -= count;</span><br><span class="line">                        count -= <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :56 ms, 在所有 C++ 提交中击败了92.67%的用户</p>
<p>内存消耗 :10.5 MB, 在所有 C++ 提交中击败了70.98%的用户</p>
</blockquote>
<hr>
<h3 id="885-Easy-螺旋矩阵III-Spiral-Matrix-III"><a href="#885-Easy-螺旋矩阵III-Spiral-Matrix-III" class="headerlink" title="#885 [Easy] 螺旋矩阵III Spiral Matrix III"></a>#885 [Easy] 螺旋矩阵III <a href="https://leetcode-cn.com/problems/spiral-matrix-iii/" target="_blank" rel="noopener">Spiral Matrix III</a></h3><blockquote>
<p>在 R 行 C 列的矩阵上，我们从 (r0, c0) 面朝东面开始</p>
<p>这里，网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。</p>
<p>现在，我们以顺时针按螺旋状行走，访问此网格中的每个位置。</p>
<p>每当我们移动到网格的边界之外时，我们会继续在网格之外行走（但稍后可能会返回到网格边界）。</p>
<p>最终，我们到过网格的所有 R * C 个空间。</p>
<p>按照访问顺序返回表示网格位置的坐标列表。</p>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= R &lt;= 100</code></li>
<li><code>1 &lt;= C &lt;= 100</code></li>
<li><code>0 &lt;= r0 &lt; R</code></li>
<li><code>0 &lt;= c0 &lt; C</code></li>
</ol>
</blockquote>
<p>看数据规模，直接模拟行走就能过，走的时候判断一下该点是否需要输出即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; spiralMatrixIII(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; point;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>, step = <span class="number">0</span>, dir, r = r0, c = c0;</span><br><span class="line">        <span class="keyword">while</span>(ans.size() &lt; R*C)&#123;</span><br><span class="line">            dir = step%<span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span>(dir == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                    point = &#123;r, c+i&#125;;</span><br><span class="line">                    <span class="keyword">if</span>(isInMat(r,c+i,R,C))</span><br><span class="line">                      ans.push_back(point);</span><br><span class="line">                &#125;</span><br><span class="line">                c += len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dir == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                    point = &#123;r+i, c&#125;;</span><br><span class="line">                    <span class="keyword">if</span>(isInMat(r+i,c,R,C)) </span><br><span class="line">                    	ans.push_back(point);</span><br><span class="line">                &#125;</span><br><span class="line">                r += len;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dir == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                    point = &#123;r, c-i&#125;;</span><br><span class="line">                    <span class="keyword">if</span>(isInMat(r,c-i,R,C))</span><br><span class="line">                      ans.push_back(point);</span><br><span class="line">                &#125;</span><br><span class="line">                c -= len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dir == <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                    point = &#123;r-i, c&#125;;</span><br><span class="line">                    <span class="keyword">if</span>(isInMat(r-i,c,R,C)) </span><br><span class="line">                      ans.push_back(point);</span><br><span class="line">                &#125;</span><br><span class="line">                r -= len;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInMat</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> R, <span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r &gt;= <span class="number">0</span> &amp;&amp; r &lt;= R<span class="number">-1</span> &amp;&amp; c &gt;=<span class="number">0</span> &amp;&amp; c &lt;= C<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :164 ms, 在所有 C++ 提交中击败了7.50%的用户</p>
<p>内存消耗 :13.5 MB, 在所有 C++ 提交中击败了84.38%的用户</p>
</blockquote>
<hr>
<h3 id="207-Medium-课程表-Course-Schedule"><a href="#207-Medium-课程表-Course-Schedule" class="headerlink" title="#207 [Medium] 课程表 Course Schedule"></a>#207 [Medium] 课程表 <a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">Course Schedule</a></h3><blockquote>
<p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p>
<p>示例 1:</p>
<p>输入: 2, [[1,0]]<br>输出: true<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</p>
<p>示例 2:</p>
<p>输入: 2, [[1,0],[0,1]]<br>输出: false<br>解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</p>
<p>说明:</p>
<p>输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。<br>你可以假定输入的先决条件中没有重复的边。</p>
<p>提示:</p>
<p>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。<br>拓扑排序也可以通过 BFS 完成。</p>
</blockquote>
<p>之前一直随机做题。。这次定向搞一道图论复习一下。</p>
<p>说明和提示里说的很清楚了，问题等价于查一个有向图中是否有环。DFS或者BFS都可以。程序和标答差不太多，主要是我习惯用自定义的节点数据结构，其实用数组做邻接表也完全可以解决。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// build the graph</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;Node*&gt; classes;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            Node *node = <span class="keyword">new</span> Node();</span><br><span class="line">            node-&gt;val = i;</span><br><span class="line">            classes.push_back(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.size();i++)&#123;</span><br><span class="line">            classes[prerequisites[i][<span class="number">0</span>]]-&gt;sub_array.push_back(classes[prerequisites[i][<span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// done</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dfs</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(classes[i]-&gt;islearn == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(classes[i]-&gt;islearn == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            search(numCourses, classes[i]);</span><br><span class="line">            <span class="keyword">if</span>(classes[i]-&gt;islearn == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> islearn = <span class="number">2</span>; <span class="comment">// 2 for undefined</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;Node*&gt; sub_array;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> numCourses, Node* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;sub_array.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            node-&gt;islearn = <span class="number">1</span>; <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;islearn = <span class="number">3</span>; <span class="comment">// 3 for searching</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;node-&gt;sub_array.size();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;sub_array[i]-&gt;islearn == <span class="number">2</span>)&#123;</span><br><span class="line">                search(numCourses, node-&gt;sub_array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;sub_array[i]-&gt;islearn == <span class="number">3</span> || node-&gt;sub_array[i]-&gt;islearn == <span class="number">0</span>)&#123;</span><br><span class="line">                    node-&gt;islearn = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;islearn = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :52 ms, 在所有 C++ 提交中击败了37.92%的用户</p>
<p>内存消耗 :13.4 MB, 在所有 C++ 提交中击败了16.84%的用户</p>
</blockquote>
<hr>
<h3 id="200-Medium-岛屿数量-Number-of-Islands"><a href="#200-Medium-岛屿数量-Number-of-Islands" class="headerlink" title="#200 [Medium] 岛屿数量 Number of Islands"></a>#200 [Medium] 岛屿数量 <a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">Number of Islands</a></h3><blockquote>
<p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
</blockquote>
<p>说来惭愧，第一次学并查集，第一次写并查集的程序。写的时候觉得DFS虽然复杂度等级一样，但是在这里应该会很慢，但实际跑了 一下DFS似乎也不慢，时间空间都好过并查集，只能说感性上的估计还是不靠谱，有时候硬写DFS也不是不行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node*&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Node*&gt;&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.size();i++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;Node*&gt; newVec;</span><br><span class="line">            <span class="built_in">map</span>.push_back(newVec);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[i].size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    Node* newNode = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">map</span>[i].push_back(newNode);</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;=<span class="number">1</span> &amp;&amp; <span class="built_in">map</span>[i<span class="number">-1</span>][j]-&gt;val == <span class="number">1</span>) <span class="built_in">map</span>[i][j]-&gt;pre = <span class="built_in">map</span>[i<span class="number">-1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=<span class="number">1</span> &amp;&amp; <span class="built_in">map</span>[i][j<span class="number">-1</span>]-&gt;val == <span class="number">1</span>) <span class="built_in">map</span>[i][j]-&gt;pre = <span class="built_in">map</span>[i][j<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;=<span class="number">1</span> &amp;&amp; j&gt;= <span class="number">1</span> &amp;&amp; <span class="built_in">map</span>[i<span class="number">-1</span>][j]-&gt;val == <span class="number">1</span> &amp;&amp; <span class="built_in">map</span>[i][j<span class="number">-1</span>]-&gt;val == <span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(Node::search(<span class="built_in">map</span>[i<span class="number">-1</span>][j]) != Node::search(<span class="built_in">map</span>[i][j<span class="number">-1</span>]))</span><br><span class="line">                            Node::search(<span class="built_in">map</span>[i][j<span class="number">-1</span>])-&gt;pre = Node::search(<span class="built_in">map</span>[i<span class="number">-1</span>][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]-&gt;pre == <span class="literal">NULL</span>) <span class="built_in">set</span>.push_back(<span class="built_in">map</span>[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    Node *newNode = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">map</span>[i].push_back(newNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="built_in">set</span>.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">set</span>.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">set</span>[i]-&gt;pre != <span class="literal">NULL</span>) ans--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Node(<span class="keyword">int</span> val)&#123; <span class="keyword">this</span>-&gt;val = val; &#125;;</span><br><span class="line">        Node *pre = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> Node* <span class="title">search</span><span class="params">(Node *node)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;pre == <span class="literal">NULL</span>) <span class="keyword">return</span> node;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> search(node-&gt;pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nodeUnion</span><span class="params">(Node *a, Node *b)</span></span>&#123;</span><br><span class="line">            Node::search(a)-&gt;pre = Node::search(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :40 ms, 在所有 C++ 提交中击败了5.71%的用户</p>
<p>内存消耗 :14.4 MB, 在所有 C++ 提交中击败了5.04%的用户</p>
</blockquote>
<hr>
<h3 id="746-Easy-使用最小花费爬楼梯-Min-Cost-Climbing-Stairs"><a href="#746-Easy-使用最小花费爬楼梯-Min-Cost-Climbing-Stairs" class="headerlink" title="#746 [Easy] 使用最小花费爬楼梯 Min Cost Climbing Stairs"></a>#746 [Easy] 使用最小花费爬楼梯 <a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">Min Cost Climbing Stairs</a></h3><blockquote>
<p>数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p>
<p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p>
</blockquote>
<p>做一道Medium的DP题练手，突然发现自己好像不会DP了，赶紧来一道Easy的DP压压惊。。</p>
<p>最优子问题是求上到第i级台阶的最小总花费，求解需要知道当前第i级台阶单级花费和第i-2/i-1级的最小总花费。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(cost.size());</span><br><span class="line">        <span class="keyword">if</span>(cost.size() == <span class="number">2</span>) <span class="keyword">return</span> min(cost[<span class="number">0</span>], cost[<span class="number">1</span>]);</span><br><span class="line">        ans[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        ans[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;cost.size();i++)&#123;</span><br><span class="line">            ans[i] = min(ans[i<span class="number">-1</span>] + cost[i], ans[i<span class="number">-2</span>] + cost[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(ans[cost.size()<span class="number">-1</span>], ans[cost.size()<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :4 ms, 在所有 C++ 提交中击败了98.79%的用户</p>
<p>内存消耗 :8.8 MB, 在所有 C++ 提交中击败了78.30%的用户</p>
</blockquote>
<hr>
<h3 id="768-Easy-托普利茨矩阵-Toeplitz-Matrix"><a href="#768-Easy-托普利茨矩阵-Toeplitz-Matrix" class="headerlink" title="#768 [Easy] 托普利茨矩阵 Toeplitz Matrix"></a>#768 [Easy] 托普利茨矩阵 <a href="https://leetcode-cn.com/problems/toeplitz-matrix/" target="_blank" rel="noopener">Toeplitz Matrix</a></h3><blockquote>
<p>如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵。</p>
<p>给定一个 M x N 的矩阵，当且仅当它是托普利茨矩阵时返回 True。</p>
</blockquote>
<p>简单的检索。Hard不会做，只能写写Easy维持生活这样子。。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isToeplitzMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = matrix.size(), y = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = matrix[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;y &amp;&amp; i+j&lt;x;j++)</span><br><span class="line">                <span class="keyword">if</span>(matrix[i+j][j] != num)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;y;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = matrix[<span class="number">0</span>][i];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;x &amp;&amp; i+j&lt;y;j++)</span><br><span class="line">                        <span class="keyword">if</span>(matrix[j][i+j] != num)  <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :12 ms, 在所有 C++ 提交中击败了91.48%的用户</p>
<p>内存消耗 :9.7 MB, 在所有 C++ 提交中击败了83.67%的用户</p>
</blockquote>
<hr>
<h3 id="643-Easy-子数组最大平均数I-Maximum-Average-Subarray-I"><a href="#643-Easy-子数组最大平均数I-Maximum-Average-Subarray-I" class="headerlink" title="#643 [Easy] 子数组最大平均数I Maximum Average Subarray I"></a>#643 [Easy] 子数组最大平均数I <a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/" target="_blank" rel="noopener">Maximum Average Subarray I</a></h3><blockquote>
<p>给定 <code>n</code> 个整数，找出平均数最大且长度为 <code>k</code> 的连续子数组，并输出该最大平均数。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMaxAverage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++) ans += nums[i];</span><br><span class="line">        sum = ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;nums.size();i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            sum -= nums[i-k];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; ans) ans = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans / k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>就是很简单的做法，然后我看其他人的代码的时候发现跑的快的几个都带了IO优化。。服辽</p>
<blockquote>
<p>执行用时 :188 ms, 在所有 C++ 提交中击败了44.39%的用户</p>
<p>内存消耗 :16.9 MB, 在所有 C++ 提交中击败了62.93%的用户</p>
</blockquote>
<hr>
<h3 id="221-Medium-最大正方形-Maximal-Square"><a href="#221-Medium-最大正方形-Maximal-Square" class="headerlink" title="#221 [Medium] 最大正方形 Maximal Square"></a>#221 [Medium] 最大正方形 <a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">Maximal Square</a></h3><blockquote>
<p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
</blockquote>
<p>这题不卡时间，直接暴力也可以做。对于每个1，开始从边长1开始找更大的正方形，并记录下当前找到的最大边长。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> y = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;y;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> newAns = findSquare(matrix, i, j);</span><br><span class="line">                <span class="keyword">if</span>(newAns &gt; ans) ans = newAns;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans*ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x+n &gt; matrix.size() || y+n &gt; matrix[<span class="number">0</span>].size()) <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;x+n &amp;&amp; i&lt;matrix.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][y+n<span class="number">-1</span>] == <span class="string">'0'</span>) <span class="keyword">return</span> n<span class="number">-1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=y;i&lt;y+n &amp;&amp; i&lt;matrix[<span class="number">0</span>].size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[x+n<span class="number">-1</span>][i] == <span class="string">'0'</span>) <span class="keyword">return</span> n<span class="number">-1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :28 ms, 在所有 C++ 提交中击败了45.78%的用户</p>
<p>内存消耗 :10.3 MB, 在所有 C++ 提交中击败了100.00%的用户</p>
</blockquote>
<p>有一个比较独特的DP的方法，其实挺难想的， 用左-左上-上的数来递推当前格的数，即对每个1，将其更新为 $\min{\text{Left, Left-Up, Up}}+1$ ，并记录最大数。格子里数的意义是以当前格为右下顶点的正方形的最大边长。[但是这样子计数矩形，是行不通的]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec(matrix[<span class="number">0</span>].size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();i++)&#123;</span><br><span class="line">            vec[i] = matrix[<span class="number">0</span>][i] - <span class="number">48</span>;</span><br><span class="line">            <span class="keyword">if</span>(vec[i] &gt; num) num = vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;matrix.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> pre_num = matrix[i<span class="number">-1</span>][<span class="number">0</span>] - <span class="number">48</span>;</span><br><span class="line">            vec[<span class="number">0</span>] = matrix[i][<span class="number">0</span>] - <span class="number">48</span>;</span><br><span class="line">            <span class="keyword">if</span>(vec[<span class="number">0</span>] &gt; num) num = vec[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;matrix[<span class="number">0</span>].size();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> mid_num = vec[j];</span><br><span class="line">                    vec[j] = min(min(vec[j<span class="number">-1</span>], pre_num), vec[j]) + <span class="number">1</span>;</span><br><span class="line">                    pre_num = mid_num;</span><br><span class="line">                    <span class="keyword">if</span>(vec[j] &gt; num) num = vec[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="string">'0'</span>) vec[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num*num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时 :44 ms, 在所有 C++ 提交中击败了11.99%的用户</p>
<p>内存消耗 :10.6 MB, 在所有 C++ 提交中击败了96.41%的用户</p>
<p>（竟然还慢过暴力。。</p>
</blockquote>
<hr>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/编程/" rel="tag"># 编程</a>
              <a href="/tags/OJ/" rel="tag"># OJ</a>
              <a href="/tags/LeetCode/" rel="tag"># LeetCode</a>
              <a href="/tags/习题/" rel="tag"># 习题</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/07/22/笔记-近似点算子/" rel="prev" title="[凸优化] 10. 近似点算子">
      <i class="fa fa-chevron-left"></i> [凸优化] 10. 近似点算子
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/08/14/OJ-LeetCode基础题目/" rel="next" title="LeetCode 基础题目">
      LeetCode 基础题目 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#799-Medium-香槟塔-Champagne-Tower"><span class="nav-number">1.</span> <span class="nav-text">#799 [Medium]香槟塔 Champagne Tower</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#235-Easy-二叉搜索树的最近公共祖先-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><span class="nav-number">2.</span> <span class="nav-text">#235 [Easy]二叉搜索树的最近公共祖先 Lowest Common Ancestor of a Binary Search Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#236-Medium-二叉树的最近公共祖先-Lowest-Common-Ancestor-of-a-Binary-Tree"><span class="nav-number">3.</span> <span class="nav-text">#236 [Medium]二叉树的最近公共祖先 Lowest Common Ancestor of a Binary Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#239-Hard-滑动窗口最大值-Sliding-Window-Maximum"><span class="nav-number">4.</span> <span class="nav-text">#239* [Hard]滑动窗口最大值 Sliding Window Maximum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#404-Easy-左子叶之和-Sum-of-Left-Leaves"><span class="nav-number">5.</span> <span class="nav-text">#404 [Easy]左子叶之和 Sum of Left Leaves</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#536-Medium-从字符串生成二叉树-Construct-Binary-Tree-from-String"><span class="nav-number">6.</span> <span class="nav-text">#536 [Medium]从字符串生成二叉树 Construct Binary Tree from String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#201-Medium-数字范围按位与-Bitwise-AND-of-Numbers-Range"><span class="nav-number">7.</span> <span class="nav-text">#201 [Medium]数字范围按位与 Bitwise AND of Numbers Range</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#242-Easy-有效的字母异位词-Valid-Anagram"><span class="nav-number">8.</span> <span class="nav-text">#242 [Easy]有效的字母异位词 Valid Anagram</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#107-Easy-二叉树的层次遍历II-Binary-Tree-Level-Order-Traversal-II"><span class="nav-number">9.</span> <span class="nav-text">#107 [Easy] 二叉树的层次遍历II Binary Tree Level Order Traversal II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#61-Medium-旋转链表-Rotate-List"><span class="nav-number">10.</span> <span class="nav-text">#61 [Medium] 旋转链表 Rotate List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1109-Medium-航班预订统计-Corporate-Flight-Bookings"><span class="nav-number">11.</span> <span class="nav-text">#1109 [Medium] 航班预订统计 Corporate Flight Bookings</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#240-Medium-搜索二维矩阵II-Search-a-2D-Matrix-II"><span class="nav-number">12.</span> <span class="nav-text">#240 [Medium] 搜索二维矩阵II Search a 2D Matrix II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#906-Hard-超级回文数-Super-Palindromes"><span class="nav-number">13.</span> <span class="nav-text">#906 [Hard] 超级回文数 Super Palindromes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#942-Easy-增减字符串匹配-DI-String-Match"><span class="nav-number">14.</span> <span class="nav-text">#942 [Easy] 增减字符串匹配 DI String Match</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#885-Easy-螺旋矩阵III-Spiral-Matrix-III"><span class="nav-number">15.</span> <span class="nav-text">#885 [Easy] 螺旋矩阵III Spiral Matrix III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#207-Medium-课程表-Course-Schedule"><span class="nav-number">16.</span> <span class="nav-text">#207 [Medium] 课程表 Course Schedule</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#200-Medium-岛屿数量-Number-of-Islands"><span class="nav-number">17.</span> <span class="nav-text">#200 [Medium] 岛屿数量 Number of Islands</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#746-Easy-使用最小花费爬楼梯-Min-Cost-Climbing-Stairs"><span class="nav-number">18.</span> <span class="nav-text">#746 [Easy] 使用最小花费爬楼梯 Min Cost Climbing Stairs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#768-Easy-托普利茨矩阵-Toeplitz-Matrix"><span class="nav-number">19.</span> <span class="nav-text">#768 [Easy] 托普利茨矩阵 Toeplitz Matrix</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#643-Easy-子数组最大平均数I-Maximum-Average-Subarray-I"><span class="nav-number">20.</span> <span class="nav-text">#643 [Easy] 子数组最大平均数I Maximum Average Subarray I</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#221-Medium-最大正方形-Maximal-Square"><span class="nav-number">21.</span> <span class="nav-text">#221 [Medium] 最大正方形 Maximal Square</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">thiswinex</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
